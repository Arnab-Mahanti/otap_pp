//writing subroutine cheevy
#include<fstream>
#include<iostream>
#include<stdlib.h>
#include<math.h>
#include<stdio.h>
#include<conio.h>
#include<map>
#include<utility>
#include<string>

//#include <boost/numeric/odeint.hpp>
#include "Eigen/Dense"
#include "Eigen/Cholesky"
#include "Eigen/LU"

using namespace Eigen;
using namespace std;



// Input Flags whose values needs to be specified by the user, can be added with more flags as per new requirement and module augmentation
struct Input_Flag {
	int Inviscid_Flag;
	int Axisymmetric;
	int Geometry;
	int Is_Cone;
	int VanDriest;
	int Full_turbulent;
	int Eckert;
	int Coordinate;
	int Sublime;
	int Mach_input;
	int Perturbation_on_Properties;
	int No_of_components;
	int Convective_data;
	int No_Thermal_response;
	int Re_transition_criteria;
	int Uniform_Initial_Temperature;
	int Propellant_to_be_considered_backnode;
	int Thickness_to_be_optimized;
	int Index_of_Layer_where_thickness_to_be_optimized;
	int Index_of_Node_where_temperature_constraint_to_be_maintained;
	int Shock_characteristics;
	int Air_Gap_Layer;
	double Temp_constarint_to_be_maintained;
	double Tolerance_Temperature_constraint;
};



// Geometry class : Need to create object of each component and assign following attributes to it
struct Geometry {
	double Radius;
	double Theta;
	double Length;
	double Lambda;
};


//Input for computing Convective Flux (Time, Altitude, Velocity) or (Time,Altitude,Mach)
struct Trajectory {
	double Time;
	double Altitude;
	double Velocity;
	double Mach_Number;
};


//Input for Wind_Tunnel Data (Mach,Total Pressure, Total_Temperature)
struct Wind_Tunnel {
    double Mach_test;
	double P_Total;
	double T_Total;
};



//Input for CFD Data (Location_data,Pressure,Temperature,Mach,Density,Gamma)
struct CFD_Data {
    double Location_data;
	double P;
	double T;
	double M;
	double rho;
	double Cp_by_Cv;
};


//Input for Time, h,Tg (Time,Heat Transfer Coefficient, Gas temperature)
struct UserInput_Convective_Flux {
	double Time;
	double h;
	double Tg;
};


//Can assign these properties to different flow regimes (Freestream, Total, Behind shock, Boundary layer, Wall)
class Properties
{
public:
	double Pressure;
	double Temperature;
	double Density;
	double Mach;
	double Viscosity;
	double Enthalpy;
	double Pr;
	double Cp;
	double Gamma;
	double Z;
	double Conductivity;
	double Velocity;
	double Cv;
	double SoundSpeed;
	double Knudsen_number;
	double Rey_No;
};



//Atmospheric Model (Nominal); Can add Upper bound, Lower bound, or any atmospheric model of user choice
void ISA_Nominal(struct Trajectory& Traj, Properties& Freestream)
{
// Will get P,T,rho as function of Altitude (double Altitude_ISA_Nominal[281],Temperature_ISA_Nominal[281],Pressure_ISA_Nominal[281],Density_ISA_Nominal[281])
	double Altitude[281] = { 0.0,   1.0,   2.0,   3.0,   4.0,   5.0,   6.0,  7.0,
		 8.0,   9.0,  10.0,  11.0,  12.0,  13.0,  14.0,  15.0,  16.0,
		17.0,  18.0,  19.0,  20.0,  21.0,  22.0,  23.0,  24.0,  25.0,
		26.0,  27.0,  28.0,  29.0,  30.0,  31.0,  32.0,  33.0,  34.0,
		35.0,  36.0,  37.0,  38.0,  39.0,  40.0,  41.0,  42.0,  43.0,
		44.0,  45.0,  46.0,  47.0,  48.0,  49.0,  50.0,  51.0,  52.0,
		53.0,  54.0,  55.0,  56.0,  57.0,  58.0,  59.0,  60.0,  61.0,
		62.0,  63.0,  64.0,  65.0,  66.0,  67.0,  68.0,  69.0,  70.0,
		71.0,  72.0,  73.0,  74.0,  75.0,  76.0,  77.0,  78.0,  79.0,
		80.0,  81.0,  82.0,  83.0,  84.0,  85.0,  86.0,  87.0,  88.0,
		89.0,  90.0,  91.0,  92.0,  93.0,  94.0,  95.0,  96.0,  97.0,
		98.0,  99.0, 100.0, 101.0, 102.0, 103.0, 104.0, 105.0, 106.0,
	   107.0, 108.0, 109.0, 110.0, 111.0, 112.0, 113.0, 114.0, 115.0,
	   116.0, 117.0, 118.0, 119.0, 120.0, 121.0, 122.0, 123.0, 124.0,
	   125.0, 126.0, 127.0, 128.0, 129.0, 130.0, 131.0, 132.0, 133.0,
	   134.0, 135.0, 136.0, 137.0, 138.0, 139.0, 140.0, 141.0, 142.0,
	   143.0, 144.0, 145.0, 146.0, 147.0, 148.0, 149.0, 150.0, 151.0,
	   152.0, 153.0, 154.0, 155.0, 156.0, 157.0, 158.0, 159.0, 160.0,
	   161.0, 162.0, 163.0, 164.0, 165.0, 166.0, 167.0, 168.0, 169.0,
	   170.0, 171.0, 172.0, 173.0, 174.0, 175.0, 176.0, 177.0, 178.0,
	   179.0, 180.0, 181.0, 182.0, 183.0, 184.0, 185.0, 186.0, 187.0,
	   188.0, 189.0, 190.0, 191.0, 192.0, 193.0, 194.0, 195.0, 196.0,
	   197.0, 198.0, 199.0, 200.0, 210.0, 220.0, 230.0, 240.0, 250.0,
	   260.0, 270.0, 280.0, 290.0, 300.0, 310.0, 320.0, 330.0, 340.0,
	   350.0, 360.0, 370.0, 380.0, 390.0, 400.0, 410.0, 420.0, 430.0,
	   440.0, 450.0, 460.0, 470.0, 480.0, 490.0, 500.0, 510.0, 520.0,
	   530.0, 540.0, 550.0, 560.0, 570.0, 580.0, 590.0, 600.0, 610.0,
	   620.0, 630.0, 640.0, 650.0, 660.0, 670.0, 680.0, 690.0, 700.0,
	   710.0, 720.0, 730.0, 740.0, 750.0, 760.0, 770.0, 780.0, 790.0,
	   800.0, 810.0, 820.0, 830.0, 840.0, 850.0, 860.0, 870.0, 880.0,
	   890.0, 900.0, 910.0, 920.0, 930.0, 940.0, 950.0, 960.0, 970.0,
	   980.0, 990.0,1000.0 };


	double Temperature[281] =
	{ 300.7, 294.6, 288.4, 283.6, 278.4, 272.9, 267.2, 261.4,
254.9, 247.9, 240.4, 232.4, 224.2, 215.9, 207.7, 200.8, 195.6,
194.2, 197.3, 201.7, 206.6, 209.1, 212.2, 215.5, 218.8, 221.3,
223.8, 226.0, 228.0, 230.3, 232.4, 234.4, 236.3, 238.4, 240.7,
243.4, 246.1, 248.9, 251.7, 254.2, 256.6, 258.9, 260.6, 262.0,
262.9, 263.8, 264.4, 264.7, 264.6, 264.1, 263.5, 262.5, 261.0,
258.9, 256.4, 253.6, 251.1, 248.5, 245.3, 241.7, 238.0, 234.1,
230.3, 226.9, 223.5, 220.4, 217.3, 213.9, 210.2, 207.3, 204.8,
203.5, 201.7, 199.5, 197.0, 194.4, 193.4, 191.4, 190.6, 188.4,
187.1, 185.6, 184.1, 182.8, 181.5, 180.3, 179.2, 178.2, 177.3,
176.5, 175.7, 175.0, 174.5, 174.0, 173.6, 173.3, 173.1, 173.0,
172.9, 173.4, 174.8, 177.1, 180.4, 184.7, 189.9, 196.0, 203.0,
210.9, 219.8, 229.5, 239.9, 251.0, 262.7, 275.0, 288.0, 301.6,
315.8, 330.5, 345.8, 361.4, 377.3, 393.3, 409.1, 424.6, 439.7,
454.4, 468.7, 482.6, 496.2, 509.4, 522.3, 534.8, 547.1, 559.0,
570.6, 581.9, 592.9, 603.6, 614.1, 624.3, 634.2, 643.9, 653.3,
662.5, 671.4, 680.1, 688.6, 696.9, 705.0, 712.8, 720.5, 727.9,
735.2, 742.3, 749.2, 755.9, 762.5, 768.8, 775.1, 781.1, 787.0,
792.8, 798.4, 803.9, 809.2, 814.4, 819.4, 824.4, 829.2, 833.9,
838.4, 842.9, 847.2, 851.4, 855.5, 859.6, 863.5, 867.3, 871.0,
874.6, 878.1, 881.6, 884.9, 888.2, 891.4, 894.5, 897.5, 900.4,
903.3, 906.1, 908.8, 911.5, 914.1, 916.6, 919.1, 921.5, 923.8,
926.1, 928.3, 930.5, 932.6, 951.0, 965.3, 976.3, 984.9, 991.6,
996.8,1000.8,1004.0,1006.4,1008.3,1009.8,1011.0,1011.9,1012.6,
1013.2,1013.6,1014.0,1014.2,1014.4,1014.6,1014.7,1014.8,1014.9,
1015.0,1015.0,1015.1,1015.1,1015.1,1015.1,1015.2,1015.2,1015.2,
1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,
1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,
1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,
1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,
1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,1015.2,
1015.2,1015.2,1015.2 };

	double Pressure[281] =
	{ 0.1009E+06,0.8998E+05,0.8006E+05,0.7107E+05,0.6297E+05,
0.5565E+05,0.4906E+05,0.4314E+05,0.3782E+05,0.3303E+05,0.2874E+05,
0.2489E+05,0.2145E+05,0.1839E+05,0.1566E+05,0.1327E+05,0.1118E+05,
0.9395E+04,0.7901E+04,0.6667E+04,0.5647E+04,0.4798E+04,0.4086E+04,
0.3488E+04,0.2985E+04,0.2560E+04,0.2199E+04,0.1892E+04,0.1631E+04,
0.1407E+04,0.1216E+04,0.1052E+04,0.9119E+03,0.7911E+03,0.6873E+03,
0.5979E+03,0.5210E+03,0.4547E+03,0.3975E+03,0.3480E+03,0.3050E+03,
0.2677E+03,0.2352E+03,0.2068E+03,0.1819E+03,0.1602E+03,0.1410E+03,
0.1242E+03,0.1094E+03,0.9638E+02,0.8487E+02,0.7471E+02,0.6572E+02,
0.5777E+02,0.5073E+02,0.4448E+02,0.3896E+02,0.3407E+02,0.2975E+02,
0.2593E+02,0.2256E+02,0.1958E+02,0.1695E+02,0.1465E+02,0.1263E+02,
0.1086E+02,0.9327E+01,0.7990E+01,0.6827E+01,0.5819E+01,0.4950E+01,
0.4204E+01,0.3567E+01,0.3021E+01,0.2556E+01,0.2157E+01,0.1817E+01,
0.1529E+01,0.1284E+01,0.1078E+01,0.9029E+00,0.8508E+00,0.7184E+00,
0.6061E+00,0.5108E+00,0.4301E+00,0.3617E+00,0.3038E+00,0.2549E+00,
0.2135E+00,0.1786E+00,0.1491E+00,0.1243E+00,0.1035E+00,0.8597E-01,
0.7135E-01,0.5916E-01,0.4903E-01,0.4065E-01,0.3373E-01,0.2805E-01,
0.2338E-01,0.1957E-01,0.1645E-01,0.1390E-01,0.1182E-01,0.1011E-01,
0.8703E-02,0.7542E-02,0.6581E-02,0.5779E-02,0.5108E-02,0.4542E-02,
0.4063E-02,0.3654E-02,0.3304E-02,0.3003E-02,0.2741E-02,0.2514E-02,
0.2314E-02,0.2139E-02,0.1984E-02,0.1846E-02,0.1723E-02,0.1612E-02,
0.1512E-02,0.1421E-02,0.1339E-02,0.1263E-02,0.1194E-02,0.1130E-02,
0.1071E-02,0.1017E-02,0.9665E-03,0.9197E-03,0.8761E-03,0.8354E-03,
0.7974E-03,0.7618E-03,0.7284E-03,0.6971E-03,0.6676E-03,0.6399E-03,
0.6137E-03,0.5890E-03,0.5656E-03,0.5435E-03,0.5226E-03,0.5027E-03,
0.4839E-03,0.4660E-03,0.4489E-03,0.4327E-03,0.4173E-03,0.4026E-03,
0.3886E-03,0.3752E-03,0.3624E-03,0.3502E-03,0.3385E-03,0.3273E-03,
0.3166E-03,0.3063E-03,0.2965E-03,0.2870E-03,0.2780E-03,0.2693E-03,
0.2610E-03,0.2530E-03,0.2452E-03,0.2378E-03,0.2307E-03,0.2238E-03,
0.2172E-03,0.2109E-03,0.2047E-03,0.1988E-03,0.1931E-03,0.1876E-03,
0.1823E-03,0.1772E-03,0.1722E-03,0.1674E-03,0.1628E-03,0.1583E-03,
0.1540E-03,0.1499E-03,0.1458E-03,0.1419E-03,0.1381E-03,0.1345E-03,
0.1309E-03,0.1275E-03,0.1242E-03,0.1209E-03,0.1178E-03,0.1148E-03,
0.1119E-03,0.1090E-03,0.1062E-03,0.1036E-03,0.8073E-04,0.6355E-04,
0.5045E-04,0.4035E-04,0.3247E-04,0.2628E-04,0.2138E-04,0.1748E-04,
0.1434E-04,0.1181E-04,0.9768E-05,0.8102E-05,0.6740E-05,0.5622E-05,
0.4701E-05,0.3940E-05,0.3310E-05,0.2786E-05,0.2350E-05,0.1986E-05,
0.1681E-05,0.1425E-05,0.1210E-05,0.1030E-05,0.8776E-06,0.7490E-06,
0.6404E-06,0.5485E-06,0.4706E-06,0.4045E-06,0.3483E-06,0.3005E-06,
0.2598E-06,0.2251E-06,0.1955E-06,0.1702E-06,0.1485E-06,0.1299E-06,
0.1140E-06,0.1003E-06,0.8846E-07,0.7830E-07,0.6954E-07,0.6196E-07,
0.5539E-07,0.4970E-07,0.4475E-07,0.4044E-07,0.3668E-07,0.3339E-07,
0.3051E-07,0.2798E-07,0.2574E-07,0.2377E-07,0.2203E-07,0.2048E-07,
0.1910E-07,0.1786E-07,0.1676E-07,0.1576E-07,0.1486E-07,0.1405E-07,
0.1332E-07,0.1265E-07,0.1203E-07,0.1147E-07,0.1095E-07,0.1048E-07,
0.1004E-07,0.9630E-08,0.9251E-08,0.8897E-08,0.8566E-08,0.8256E-08,
0.7965E-08,0.7692E-08,0.7433E-08,0.7190E-08,0.6959E-08,0.6740E-08 };

	double Density[281] =
	{ 0.1169E+01,0.1064E+01,0.9672E+00,0.8730E+00,0.7881E+00,
0.7106E+00,0.6397E+00,0.5749E+00,0.5169E+00,0.4643E+00,0.4166E+00,
0.3732E+00,0.3334E+00,0.2967E+00,0.2627E+00,0.2302E+00,0.1991E+00,
0.1686E+00,0.1395E+00,0.1152E+00,0.9526E-01,0.7994E-01,0.6709E-01,
0.5640E-01,0.4753E-01,0.4030E-01,0.3423E-01,0.2915E-01,0.2491E-01,
0.2129E-01,0.1824E-01,0.1564E-01,0.1344E-01,0.1156E-01,0.9946E-02,
0.8559E-02,0.7375E-02,0.6364E-02,0.5502E-02,0.4769E-02,0.4141E-02,
0.3603E-02,0.3144E-02,0.2750E-02,0.2411E-02,0.2115E-02,0.1859E-02,
0.1635E-02,0.1441E-02,0.1272E-02,0.1122E-02,0.9917E-03,0.8776E-03,
0.7777E-03,0.6893E-03,0.6111E-03,0.5405E-03,0.4775E-03,0.4226E-03,
0.3739E-03,0.3303E-03,0.2914E-03,0.2565E-03,0.2250E-03,0.1969E-03,
0.1718E-03,0.1496E-03,0.1301E-03,0.1132E-03,0.9779E-04,0.8422E-04,
0.7198E-04,0.6163E-04,0.5277E-04,0.4486E-04,0.3866E-04,0.3274E-04,
0.2784E-04,0.2349E-04,0.1994E-04,0.1681E-04,0.1475E-04,0.1252E-04,
0.1063E-04,0.9011E-05,0.7638E-05,0.6471E-05,0.5480E-05,0.4638E-05,
0.3924E-05,0.3317E-05,0.2802E-05,0.2363E-05,0.1988E-05,0.1668E-05,
0.1396E-05,0.1164E-05,0.9666E-06,0.8002E-06,0.6602E-06,0.5430E-06,
0.4453E-06,0.3646E-06,0.2985E-06,0.2445E-06,0.2006E-06,0.1650E-06,
0.1361E-06,0.1128E-06,0.9385E-07,0.7851E-07,0.6606E-07,0.5589E-07,
0.4755E-07,0.4068E-07,0.3498E-07,0.3023E-07,0.2627E-07,0.2294E-07,
0.2013E-07,0.1776E-07,0.1575E-07,0.1404E-07,0.1258E-07,0.1133E-07,
0.1025E-07,0.9312E-08,0.8492E-08,0.7770E-08,0.7132E-08,0.6566E-08,
0.6062E-08,0.5610E-08,0.5204E-08,0.4839E-08,0.4508E-08,0.4208E-08,
0.3935E-08,0.3686E-08,0.3458E-08,0.3250E-08,0.3058E-08,0.2882E-08,
0.2719E-08,0.2568E-08,0.2429E-08,0.2300E-08,0.2180E-08,0.2068E-08,
0.1964E-08,0.1867E-08,0.1777E-08,0.1692E-08,0.1612E-08,0.1538E-08,
0.1467E-08,0.1402E-08,0.1340E-08,0.1281E-08,0.1226E-08,0.1174E-08,
0.1125E-08,0.1078E-08,0.1034E-08,0.9925E-09,0.9529E-09,0.9154E-09,
0.8798E-09,0.8460E-09,0.8138E-09,0.7832E-09,0.7541E-09,0.7263E-09,
0.6998E-09,0.6746E-09,0.6505E-09,0.6274E-09,0.6054E-09,0.5844E-09,
0.5643E-09,0.5450E-09,0.5266E-09,0.5089E-09,0.4920E-09,0.4757E-09,
0.4602E-09,0.4452E-09,0.4309E-09,0.4171E-09,0.4039E-09,0.3911E-09,
0.3789E-09,0.3671E-09,0.3558E-09,0.3449E-09,0.3344E-09,0.3243E-09,
0.3146E-09,0.3052E-09,0.2961E-09,0.2874E-09,0.2152E-09,0.1635E-09,
0.1258E-09,0.9786E-10,0.7681E-10,0.6078E-10,0.4844E-10,0.3885E-10,
0.3134E-10,0.2541E-10,0.2070E-10,0.1694E-10,0.1392E-10,0.1148E-10,
0.9502E-11,0.7887E-11,0.6565E-11,0.5479E-11,0.4584E-11,0.3843E-11,
0.3229E-11,0.2718E-11,0.2292E-11,0.1936E-11,0.1637E-11,0.1387E-11,
0.1177E-11,0.9997E-12,0.8504E-12,0.7242E-12,0.6176E-12,0.5273E-12,
0.4507E-12,0.3857E-12,0.3305E-12,0.2836E-12,0.2436E-12,0.2095E-12,
0.1805E-12,0.1556E-12,0.1344E-12,0.1163E-12,0.1008E-12,0.8744E-13,
0.7602E-13,0.6622E-13,0.5779E-13,0.5054E-13,0.4430E-13,0.3891E-13,
0.3427E-13,0.3025E-13,0.2678E-13,0.2377E-13,0.2116E-13,0.1889E-13,
0.1691E-13,0.1519E-13,0.1369E-13,0.1238E-13,0.1123E-13,0.1022E-13,
0.9330E-14,0.8547E-14,0.7854E-14,0.7241E-14,0.6696E-14,0.6211E-14,
0.5779E-14,0.5391E-14,0.5044E-14,0.4731E-14,0.4448E-14,0.4192E-14,
0.3960E-14,0.3748E-14,0.3555E-14,0.3377E-14,0.3214E-14,0.3064E-14 };





	for (int k = 0; k < 281; k++)
	{
		if (Traj.Altitude == Altitude[k])
		{
			Freestream.Pressure = Pressure[k];
			Freestream.Temperature = Temperature[k];
			Freestream.Density = Density[k];
			k = 281;
		}

		if (Traj.Altitude > Altitude[k] && Traj.Altitude < Altitude[k + 1])
		{
			Freestream.Pressure = Pressure[k] + (Pressure[k + 1] - Pressure[k]) / (Altitude[k + 1] - Altitude[k]) * (Traj.Altitude - Altitude[k]);
			Freestream.Temperature = Temperature[k] + (Temperature[k + 1] - Temperature[k]) / (Altitude[k + 1] - Altitude[k]) * (Traj.Altitude - Altitude[k]);
			Freestream.Density = Density[k] + (Density[k + 1] - Density[k]) / (Altitude[k + 1] - Altitude[k]) * (Traj.Altitude - Altitude[k]);
			k = 281;
		}

	}
	double Gas_Constant;
	Gas_Constant = Freestream.Pressure / (Freestream.Density * Freestream.Temperature);
	Freestream.SoundSpeed = sqrt(1.4 * Gas_Constant * Freestream.Temperature);


}


// Will get properties (Cp,Gamma,Pr,Z,Enthalpy,Density,k)of gas as function of Pressure,Temperature; For Temperature<500 use ideal gas relations
void Hansen(Properties& Flow)
{

	double T_Table[30] = { 500,1000,1500,2000,2500,3000,3500,4000,4500,5000,5500,6000,6500,7000,7500,8000,8500,9000,9500,10000,10500,11000,11500,12000,12500,13000,13500,14000,14500,15000 };

	double P_Table[7] = { 2,1,0,-1,-2,-3,-4 };


	double k_Table[30][7] = { {	0.0372	,	0.0372	,	0.0372	,	0.0372	,	0.0372	,	0.0372	,	0.0372	}	,
{	0.0624	,	0.0624	,	0.0624	,	0.0624	,	0.0624	,	0.0624	,	0.0624	}	,
{	0.0826	,	0.0826	,	0.0826	,	0.0826	,	0.0826	,	0.0826	,	0.0826	}	,
{	0.0994	,	0.0994	,	0.0994	,	0.1057	,	0.1233	,	0.1765	,	0.337	}	,
{	0.1199	,	0.1257	,	0.1545	,	0.2386	,	0.4419	,	0.732	,	0.5249	}	,
{	0.1496	,	0.203	,	0.3369	,	0.577	,	0.6339	,	0.2306	,	0.1543	}	,
{	0.2219	,	0.3601	,	0.5396	,	0.4527	,	0.1965	,	0.2412	,	0.4241	}	,
{	0.33	,	0.4834	,	0.3668	,	0.1963	,	0.357	,	0.741	,	1.844	}	,
{	0.4203	,	0.3994	,	0.2237	,	0.4333	,	0.958	,	2.304	,	3.981	}	,
{	0.4234	,	0.2754	,	0.4538	,	0.9903	,	2.294	,	3.558	,	1.633	}	,
{	0.3566	,	0.4218	,	0.8682	,	1.987	,	3.218	,	1.652	,	0.5131	}	,
{	0.2927	,	0.6869	,	1.545	,	2.842	,	1.985	,	0.6005	,	0.9311	}	,
{	0.5295	,	1.103	,	2.292	,	2.432	,	0.8677	,	0.9357	,	2.053	}	,
{	0.7702	,	1.637	,	2.577	,	1.366	,	0.5386	,	1.798	,	4.417	}	,
{	1.074	,	2.124	,	2.083	,	1.007	,	1.467	,	3.398	,	8.831	}	,
{	1.444	,	2.32	,	1.372	,	0.6016	,	2.461	,	6.104	,	14.92	}	,
{	1.789	,	2.096	,	0.9255	,	1.764	,	4.01	,	10.22	,	19.53	}	,
{	2.037	,	1.642	,	0.6092	,	2.622	,	6.372	,	14.72	,	17.53	}	,
{	2.09	,	1.226	,	1.279	,	3.9	,	9.432	,	17.79	,	10.55	}	,
{	1.946	,	0.8026	,	2.159	,	5.561	,	12.78	,	16.72	,	5.049	}	,
{	1.684	,	1.314	,	2.952	,	7.602	,	15.49	,	12.11	,	2.315	}	,
{	1.416	,	1.754	,	3.969	,	10	,	16.27	,	7.288	,	1.203	}	,
{	1.184	,	2.22	,	5.189	,	12.33	,	14.53	,	4.032	,	0.7201	}	,
{	1.037	,	2.805	,	6.688	,	14.15	,	11.17	,	2.327	,	0.4956	}	,
{	0.7381	,	3.436	,	8.176	,	14.87	,	7.69	,	1.346	,	0.3993	}	,
{	1.303	,	4.231	,	9.761	,	14.29	,	5.072	,	0.9197	,	0.3656	}	,
{	2.286	,	5.124	,	11.19	,	12.52	,	3.281	,	0.7307	,	0.3357	}	,
{	2.678	,	6.063	,	12.24	,	10.18	,	2.242	,	0.6461	,	0.3713	}	,
{	3.272	,	7.482	,	12.92	,	7.244	,	1.489	,	0.579	,	0.3979	}	,
{	3.624	,	8.194	,	12.7	,	5.891	,	0.737	,	0.5648	,	0.4252	} };


	double mu_Table[30][7] = { {	2.67E-05	,	2.67E-05	,	2.67E-05	,	2.67E-05	,	2.67E-05	,	2.67E-05	,	2.67E-05	}	,
{	4.16E-05	,	4.16E-05	,	4.16E-05	,	4.16E-05	,	4.16E-05	,	4.16E-05	,	4.16E-05	}	,
{	5.27E-05	,	5.27E-05	,	5.27E-05	,	5.27E-05	,	5.27E-05	,	5.27E-05	,	5.27E-05	}	,
{	6.19E-05	,	6.19E-05	,	6.19E-05	,	6.19E-05	,	6.19E-05	,	6.19E-05	,	6.19E-05	}	,
{	7.00E-05	,	7.00E-05	,	7.00E-05	,	7.00E-05	,	7.00E-05	,	7.00E-05	,	7.00E-05	}	,
{	7.72E-05	,	7.72E-05	,	7.72E-05	,	7.72E-05	,	7.72E-05	,	7.72E-05	,	7.72E-05	}	,
{	8.38E-05	,	8.39E-05	,	8.41E-05	,	8.43E-05	,	8.47E-05	,	8.47E-05	,	8.47E-05	}	,
{	9.02E-05	,	9.07E-05	,	9.14E-05	,	9.18E-05	,	9.19E-05	,	9.21E-05	,	9.28E-05	}	,
{	9.67E-05	,	9.78E-05	,	9.85E-05	,	9.89E-05	,	9.93E-05	,	1.01E-04	,	1.05E-04	}	,
{	1.03E-04	,	1.05E-04	,	1.06E-04	,	1.06E-04	,	1.09E-04	,	1.02E-04	,	1.19E-04	}	,
{	1.10E-04	,	1.12E-04	,	1.13E-04	,	1.15E-04	,	1.22E-04	,	1.29E-04	,	1.30E-04	}	,
{	1.17E-04	,	1.19E-04	,	1.21E-04	,	1.28E-04	,	1.37E-04	,	1.40E-04	,	1.40E-04	}	,
{	1.24E-04	,	1.26E-04	,	1.32E-04	,	1.44E-04	,	1.48E-04	,	1.49E-04	,	1.47E-04	}	,
{	1.31E-04	,	1.35E-04	,	1.45E-04	,	1.56E-04	,	1.59E-04	,	1.57E-04	,	1.52E-04	}	,
{	1.39E-04	,	1.47E-04	,	1.60E-04	,	1.66E-04	,	1.67E-04	,	1.63E-04	,	1.51E-04	}	,
{	1.47E-04	,	1.60E-04	,	1.73E-04	,	1.77E-04	,	1.74E-04	,	1.65E-04	,	1.38E-04	}	,
{	1.58E-04	,	1.74E-04	,	1.84E-04	,	1.84E-04	,	1.79E-04	,	1.61E-04	,	1.10E-04	}	,
{	1.70E-04	,	1.87E-04	,	1.95E-04	,	1.91E-04	,	1.80E-04	,	1.46E-04	,	7.08E-05	}	,
{	1.83E-04	,	2.00E-04	,	2.03E-04	,	1.96E-04	,	1.76E-04	,	1.20E-04	,	3.68E-05	}	,
{	1.97E-04	,	2.12E-04	,	2.09E-04	,	1.99E-04	,	1.65E-04	,	8.60E-05	,	1.71E-05	}	,
{	2.10E-04	,	2.22E-04	,	2.15E-04	,	1.98E-04	,	1.46E-04	,	5.35E-05	,	8.15E-06	}	,
{	2.23E-04	,	2.28E-04	,	2.19E-04	,	1.92E-04	,	1.19E-04	,	3.04E-05	,	4.40E-06	}	,
{	2.34E-04	,	2.35E-04	,	2.21E-04	,	1.81E-04	,	8.87E-05	,	1.68E-05	,	2.80E-06	}	,
{	2.46E-04	,	2.41E-04	,	2.21E-04	,	1.65E-04	,	6.14E-05	,	1.00E-05	,	1.90E-06	}	,
{	2.56E-04	,	2.46E-04	,	2.17E-04	,	1.43E-04	,	4.03E-05	,	5.83E-06	,	1.46E-06	}	,
{	2.61E-04	,	2.49E-04	,	2.11E-04	,	1.18E-04	,	2.61E-05	,	3.97E-06	,	1.32E-06	}	,
{	2.69E-04	,	2.51E-04	,	2.00E-04	,	9.22E-05	,	1.69E-05	,	3.03E-06	,	1.18E-06	}	,
{	2.74E-04	,	2.52E-04	,	1.86E-04	,	7.00E-05	,	1.15E-05	,	2.57E-06	,	1.20E-06	}	,
{	2.80E-04	,	2.47E-04	,	1.64E-04	,	4.68E-05	,	7.34E-06	,	2.27E-06	,	1.40E-06	}	,
{	2.85E-04	,	2.47E-04	,	1.47E-04	,	3.77E-05	,	2.84E-06	,	2.13E-06	,	1.42E-06	} };


	double Pr_Table[30][7] = { {	0.738	,	0.738	,	0.738	,	0.738	,	0.738	,	0.738	,	0.738	}	,
	{	0.756	,	0.756	,	0.756	,	0.756	,	0.756	,	0.756	,	0.756	}	,
	{	0.767	,	0.767	,	0.767	,	0.767	,	0.767	,	0.767	,	0.767	}	,
	{	0.773	,	0.773	,	0.773	,	0.766	,	0.724	,	0.668	,	0.614	}	,
	{	0.762	,	0.751	,	0.696	,	0.645	,	0.611	,	0.654	,	0.771	}	,
	{	0.74	,	0.68	,	0.627	,	0.636	,	0.74	,	0.745	,	0.714	}	,
	{	0.678	,	0.631	,	0.66	,	0.744	,	0.737	,	0.658	,	0.606	}	,
	{	0.64	,	0.662	,	0.762	,	0.759	,	0.619	,	0.58	,	0.587	}	,
	{	0.654	,	0.743	,	0.752	,	0.61	,	0.578	,	0.611	,	0.764	}	,
	{	0.702	,	0.767	,	0.611	,	0.581	,	0.624	,	0.799	,	0.993	}	,
	{	0.748	,	0.62	,	0.583	,	0.617	,	0.785	,	0.989	,	0.871	}	,
	{	0.763	,	0.592	,	0.602	,	0.736	,	0.969	,	0.891	,	0.455	}	,
	{	0.61	,	0.592	,	0.673	,	0.906	,	0.955	,	0.464	,	0.392	}	,
	{	0.593	,	0.62	,	0.796	,	0.986	,	0.83	,	0.404	,	0.361	}	,
	{	0.595	,	0.688	,	0.927	,	0.969	,	0.424	,	0.371	,	0.342	}	,
	{	0.62	,	0.788	,	0.983	,	0.648	,	0.387	,	0.351	,	0.322	}	,
	{	0.666	,	0.891	,	0.943	,	0.411	,	0.363	,	0.355	,	0.279	}	,
	{	730	,	0.961	,	0.807	,	0.382	,	0.348	,	0.316	,	0.2	}	,
	{	0.806	,	0.966	,	0.497	,	0.364	,	0.336	,	0.279	,	0.114	}	,
	{	0.886	,	0.872	,	0.429	,	0.348	,	0.319	,	0.216	,	0.0576	}	,
	{	0.937	,	0.532	,	0.404	,	0.339	,	0.295	,	0.145	,	0.0314	}	,
	{	0.955	,	0.463	,	0.382	,	0.327	,	0.254	,	0.0877	,	0.0213	}	,
	{	947	,	0.434	,	0.369	,	0.312	,	0.201	,	0.0524	,	0.0167	}	,
	{	0.908	,	0.412	,	0.355	,	0.292	,	0.146	,	0.0346	,	0.0143	}	,
	{	0.728	,	0.396	,	0.343	,	0.263	,	0.101	,	0.0238	,	0.0129	}	,
	{	0.525	,	0.383	,	0.333	,	0.227	,	0.0688	,	0.019	,	0.0121	}	,
	{	0.438	,	0.369	,	0.319	,	0.185	,	0.047	,	0.0162	,	0.011	}	,
	{	0.421	,	0.36	,	0.302	,	0.144	,	0.0345	,	0.0149	,	0.0108	}	,
	{	0.401	,	0.349	,	0.277	,	0.0986	,	0.0245	,	0.013	,	0.0109	}	,
	{	0.394	,	0.341	,	0.253	,	0.0819	,	0.0129	,	0.012	,	0.011	} };

	double Cp_Table[30][7] = { {	1030.3	,	1030.3	,	1030.3	,	1030.3	,	1030.3	,	1030.3	,	1030.3	}	,
{	1136.5	,	1136.5	,	1136.5	,	1136.5	,	1136.5	,	1136.5	,	1136.5	}	,
{	1205.4	,	1205.4	,	1205.4	,	1205.4	,	1208.3	,	1214	,	1231.2	}	,
{	1245.6	,	1248.4	,	1265.7	,	1311.6	,	1463.7	,	1931.5	,	3320.6	}	,
{	1294.4	,	1360.4	,	1567	,	2189.8	,	3897.5	,	6888	,	5748.6	}	,
{	1443.6	,	1788	,	2760.9	,	4775.7	,	5068.4	,	2261.6	,	1552.7	}	,
{	1799.5	,	2726.5	,	4276.3	,	3533	,	1868.4	,	1905.7	,	3068	}	,
{	2364.9	,	3578.9	,	3171.4	,	1983.2	,	2436.6	,	4724	,	11703.9	}	,
{	2904.4	,	3174.2	,	2189.8	,	2758.1	,	5648.2	,	14080.2	,	29127.6	}	,
{	3022.1	,	2459.6	,	2749.5	,	5447.3	,	13265.1	,	25020.7	,	13629.6	}	,
{	2743.7	,	2600.2	,	4548.9	,	10687.9	,	20864.9	,	12794.5	,	3679.3	}	,
{	2597.4	,	3553.1	,	7734.7	,	16531.2	,	14169.2	,	4350.9	,	3280.4	}	,
{	2884.4	,	5255	,	11804.3	,	15604.2	,	5912.2	,	3375.1	,	5490.3	}	,
{	3587.5	,	7605.5	,	14235.2	,	8948.7	,	3699.4	,	4701.1	,	10567.3	}	,
{	4729.8	,	10099.5	,	12252	,	4970.8	,	4015.1	,	7754.7	,	20095.7	}	,
{	6147.5	,	11574.7	,	8113.5	,	3926.2	,	5567.8	,	13092.9	,	34899.2	}	,
{	7662.9	,	10946.2	,	5332.5	,	4279.2	,	8279.9	,	21329.8	,	49754.3	}	,
{	8911.4	,	8719.1	,	4256.2	,	5424.3	,	12372.6	,	31989	,	49742.8	}	,
{	9442.3	,	6457.5	,	4204.6	,	7249.6	,	17992	,	41310.8	,	32993.5	}	,
{	9020.4	,	5011	,	4744.1	,	9789.6	,	24805.4	,	42217.7	,	17303.2	}	,
{	7881	,	4359.5	,	5699.8	,	13067.1	,	31380.6	,	32936.1	,	9181.1	}	,
{	9419.3	,	4256.2	,	7020	,	17004.8	,	34950.9	,	21094.5	,	5717	}	,
{	5441.5	,	4508.8	,	8687.5	,	21266.7	,	33142.8	,	12679.7	,	4284.9	}	,
{	4703.9	,	5008.2	,	10685	,	25132.6	,	26800.1	,	8010.2	,	3679.3	}	,
{	4307.9	,	5705.6	,	12963.8	,	27554.9	,	19332.3	,	5645.3	,	3412.4	}	,
{	4181.6	,	6569.4	,	15411.9	,	27595	,	13302.5	,	4465.7	,	3291.9	}	,
{	4247.6	,	7582.5	,	17828.4	,	25138.3	,	9270.1	,	3871.6	,	3231.6	}	,
{	4454.2	,	8727.7	,	19920.7	,	21071.5	,	6807.6	,	3561.7	,	3202.9	}	,
{	4769.9	,	9979	,	21341.3	,	16733.8	,	5355.4	,	3395.2	,	3185.7	}	,
{	5171.7	,	11299.2	,	21797.7	,	12814.6	,	4505.9	,	3303.4	,	3180	} };

	double G_Table[30][7] = { {	1.387	,	1.387	,	1.387	,	1.387	,	1.387	,	1.387	,	1.387	}	,
{	1.337	,	1.337	,	1.337	,	1.337	,	1.337	,	1.337	,	1.337	}	,
{	1.312	,	1.312	,	1.312	,	1.312	,	1.312	,	1.31	,	1.306	}	,
{	1.3	,	1.299	,	1.296	,	1.286	,	1.26	,	1.209	,	1.153	}	,
{	1.288	,	1.277	,	1.249	,	1.202	,	1.161	,	1.152	,	1.157	}	,
{	1.266	,	1.235	,	1.195	,	1.178	,	1.181	,	1.239	,	1.304	}	,
{	1.241	,	1.211	,	1.202	,	1.212	,	1.27	,	1.252	,	1.176	}	,
{	1.23	,	1.223	,	1.23	,	1.26	,	1.213	,	1.15	,	1.133	}	,
{	1.24	,	1.243	,	1.251	,	1.204	,	1.154	,	1.155	,	1.19	}	,
{	1.256	,	1.252	,	1.212	,	1.166	,	1.172	,	1.203	,	1.168	}	,
{	1.262	,	1.231	,	1.183	,	1.182	,	1.214	,	1.183	,	1.257	}	,
{	1.253	,	1.206	,	1.19	,	1.221	,	1.202	,	1.237	,	1.266	}	,
{	1.235	,	1.201	,	1.22	,	1.228	,	1.217	,	1.265	,	1.188	}	,
{	1.223	,	1.217	,	1.246	,	1.216	,	1.258	,	1.21	,	1.155	}	,
{	1.223	,	1.243	,	1.244	,	1.237	,	1.237	,	1.173	,	1.164	}	,
{	1.235	,	1.264	,	1.235	,	1.252	,	1.201	,	1.168	,	1.201	}	,
{	1.255	,	1.267	,	1.243	,	1.235	,	1.183	,	1.188	,	1.242	}	,
{	1.275	,	1.26	,	1.252	,	1.213	,	1.185	,	1.224	,	1.244	}	,
{	1.288	,	1.255	,	1.248	,	1.201	,	1.203	,	1.256	,	1.216	}	,
{	1.291	,	1.259	,	1.236	,	1.201	,	1.232	,	1.263	,	1.211	}	,
{	1.287	,	1.262	,	1.226	,	1.213	,	1.263	,	1.244	,	1.256	}	,
{	1.282	,	1.261	,	1.222	,	1.233	,	1.281	,	1.23	,	1.339	}	,
{	1.28	,	1.256	,	1.226	,	1.258	,	1.28	,	1.243	,	1.427	}	,
{	1.282	,	1.252	,	1.236	,	1.283	,	1.267	,	1.288	,	1.491	}	,
{	1.284	,	1.25	,	1.251	,	1.301	,	1.257	,	1.352	,	1.528	}	,
{	1.285	,	1.251	,	1.271	,	1.307	,	1.263	,	1.419	,	1.548	}	,
{	1.284	,	1.257	,	1.291	,	1.303	,	1.288	,	1.472	,	1.558	}	,
{	1.284	,	1.266	,	1.311	,	1.295	,	1.329	,	1.509	,	1.563	}	,
{	1.284	,	1.278	,	1.326	,	1.29	,	1.377	,	1.532	,	1.565	}	,
{	1.286	,	1.293	,	1.336	,	1.293	,	1.425	,	1.547	,	1.567	} };


	double H_Table[30][7] = { {	5.05E+05	,	5.05E+05	,	5.05E+05	,	5.05E+05	,	5.05E+05	,	5.05E+05	,	5.05E+05	}	,
{	1.05E+06	,	1.05E+06	,	1.05E+06	,	1.05E+06	,	1.05E+06	,	1.05E+06	,	1.05E+06	}	,
{	1.64E+06	,	1.64E+06	,	1.64E+06	,	1.64E+06	,	1.64E+06	,	1.64E+06	,	1.64E+06	}	,
{	2.25E+06	,	2.25E+06	,	2.25E+06	,	2.26E+06	,	2.28E+06	,	2.34E+06	,	2.53E+06	}	,
{	2.88E+06	,	2.89E+06	,	2.94E+06	,	3.06E+06	,	3.45E+06	,	4.42E+06	,	5.75E+06	}	,
{	3.56E+06	,	3.66E+06	,	3.97E+06	,	4.78E+06	,	6.14E+06	,	6.91E+06	,	7.05E+06	}	,
{	4.36E+06	,	4.77E+06	,	5.78E+06	,	7.11E+06	,	7.65E+06	,	7.81E+06	,	8.07E+06	}	,
{	5.40E+06	,	6.38E+06	,	7.74E+06	,	8.36E+06	,	8.64E+06	,	9.29E+06	,	1.13E+07	}	,
{	6.72E+06	,	8.12E+06	,	9.02E+06	,	9.47E+06	,	1.05E+07	,	1.36E+07	,	2.17E+07	}	,
{	8.22E+06	,	9.50E+06	,	1.02E+07	,	1.14E+07	,	1.50E+07	,	2.39E+07	,	3.37E+07	}	,
{	9.68E+06	,	1.07E+07	,	1.20E+07	,	1.54E+07	,	2.39E+07	,	3.41E+07	,	3.72E+07	}	,
{	1.10E+07	,	1.22E+07	,	1.50E+07	,	2.23E+07	,	3.32E+07	,	3.78E+07	,	3.88E+07	}	,
{	1.24E+07	,	1.44E+07	,	1.99E+07	,	3.07E+07	,	3.80E+07	,	3.96E+07	,	4.09E+07	}	,
{	1.40E+07	,	1.76E+07	,	2.65E+07	,	3.69E+07	,	4.02E+07	,	4.16E+07	,	4.46E+07	}	,
{	1.60E+07	,	2.20E+07	,	3.33E+07	,	4.02E+07	,	4.21E+07	,	4.46E+07	,	5.22E+07	}	,
{	1.87E+07	,	2.75E+07	,	3.84E+07	,	4.23E+07	,	4.44E+07	,	4.97E+07	,	6.58E+07	}	,
{	2.22E+07	,	3.33E+07	,	4.17E+07	,	4.43E+07	,	4.78E+07	,	5.82E+07	,	8.72E+07	}	,
{	2.64E+07	,	3.82E+07	,	4.40E+07	,	4.67E+07	,	5.29E+07	,	7.15E+07	,	1.13E+08	}	,
{	3.10E+07	,	4.20E+07	,	4.61E+07	,	4.99E+07	,	6.05E+07	,	9.00E+07	,	1.34E+08	}	,
{	3.57E+07	,	4.48E+07	,	4.83E+07	,	5.41E+07	,	7.11E+07	,	1.11E+08	,	1.46E+08	}	,
{	3.99E+07	,	4.71E+07	,	5.09E+07	,	5.98E+07	,	8.52E+07	,	1.30E+08	,	1.53E+08	}	,
{	4.35E+07	,	4.93E+07	,	5.41E+07	,	6.73E+07	,	1.02E+08	,	1.44E+08	,	1.56E+08	}	,
{	4.65E+07	,	5.14E+07	,	5.80E+07	,	7.68E+07	,	1.19E+08	,	1.52E+08	,	1.59E+08	}	,
{	4.90E+07	,	5.38E+07	,	6.28E+07	,	8.85E+07	,	1.34E+08	,	1.57E+08	,	1.61E+08	}	,
{	5.12E+07	,	5.65E+07	,	6.87E+07	,	1.02E+08	,	1.46E+08	,	1.61E+08	,	1.62E+08	}	,
{	5.34E+07	,	5.96E+07	,	7.58E+07	,	1.16E+08	,	1.54E+08	,	1.63E+08	,	1.64E+08	}	,
{	5.54E+07	,	6.31E+07	,	8.42E+07	,	1.29E+08	,	1.60E+08	,	1.65E+08	,	1.66E+08	}	,
{	5.76E+07	,	6.71E+07	,	9.36E+07	,	1.41E+08	,	1.64E+08	,	1.67E+08	,	1.67E+08	}	,
{	5.99E+07	,	7.18E+07	,	1.04E+08	,	1.50E+08	,	1.67E+08	,	1.69E+08	,	1.69E+08	}	,
{	6.24E+07	,	7.72E+07	,	1.15E+08	,	1.57E+08	,	1.69E+08	,	1.70E+08	,	1.71E+08	} };

	double Z_Table[30][7] = { {	1	,	1	,	1	,	1	,	1	,	1	,	1	}	,
	{	1	,	1	,	1	,	1	,	1	,	1	,	1	}	,
	{	1	,	1	,	1	,	1	,	1	,	1	,	1	}	,
	{	1	,	1	,	1	,	1.001	,	1.002	,	1.005	,	1.016	}	,
	{	1	,	1.001	,	1.004	,	1.011	,	1.033	,	1.088	,	1.163	}	,
	{	1.003	,	1.009	,	1.026	,	1.072	,	1.149	,	1.192	,	1.2	}	,
	{	1.012	,	1.035	,	1.092	,	1.167	,	1.197	,	1.203	,	1.211	}	,
	{	1.033	,	1.089	,	1.165	,	1.198	,	1.208	,	1.228	,	1.287	}	,
	{	1.071	,	1.149	,	1.196	,	1.213	,	1.245	,	1.337	,	1.577	}	,
	{	1.118	,	1.186	,	1.214	,	1.252	,	1.359	,	1.622	,	1.91	}	,
	{	1.159	,	1.208	,	1.248	,	1.348	,	1.599	,	1.898	,	1.99	}	,
	{	1.189	,	1.235	,	1.316	,	1.529	,	1.849	,	1.983	,	2.008	}	,
	{	1.214	,	1.279	,	1.437	,	1.752	,	1.961	,	2.006	,	2.032	}	,
	{	1.243	,	1.351	,	1.607	,	1.904	,	1.997	,	2.027	,	2.088	}	,
	{	1.284	,	1.457	,	1.778	,	1.971	,	2.017	,	2.067	,	2.21	}	,
	{	1.341	,	1.59	,	1.896	,	2.001	,	2.044	,	2.144	,	2.446	}	,
	{	1.418	,	1.727	,	1.959	,	2.023	,	2.09	,	2.284	,	2.826	}	,
	{	1.512	,	1.838	,	1.993	,	2.05	,	2.166	,	2.51	,	3.282	}	,
	{	1.616	,	1.914	,	2.018	,	2.09	,	2.286	,	2.832	,	3.645	}	,
	{	1.718	,	1.962	,	2.042	,	2.149	,	2.462	,	3.202	,	3.843	}	,
	{	1.807	,	1.993	,	2.071	,	2.234	,	2.7	,	3.526	,	3.932	}	,
	{	1.876	,	2.018	,	2.111	,	2.351	,	2.983	,	3.745	,	3.969	}	,
	{	1.927	,	2.042	,	2.163	,	2.505	,	3.272	,	3.867	,	3.985	}	,
	{	1.965	,	2.067	,	2.232	,	2.694	,	3.52	,	3.931	,	3.993	}	,
	{	1.993	,	2.098	,	2.318	,	2.91	,	3.7	,	3.963	,	3.996	}	,
	{	2.017	,	2.135	,	2.426	,	3.135	,	3.818	,	3.979	,	3.998	}	,
	{	2.039	,	2.18	,	2.553	,	3.347	,	3.889	,	3.988	,	3.999	}	,
	{	2.062	,	2.233	,	2.7	,	3.527	,	3.932	,	3.993	,	3.999	}	,
	{	2.086	,	2.297	,	2.861	,	3.667	,	3.957	,	3.996	,	4	}	,
	{	2.113	,	2.372	,	3.028	,	3.769	,	3.973	,	3.997	,	4	} };

	double A2_Table[30][7] = { {	1.387	,	1.387	,	1.387	,	1.387	,	1.387	,	1.387	,	1.387	}	,
	{	1.337	,	1.337	,	1.337	,	1.337	,	1.337	,	1.337	,	1.337	}	,
	{	1.312	,	1.312	,	1.312	,	1.312	,	1.312	,	1.31	,	1.306	}	,
	{	1.3	,	1.299	,	1.296	,	1.285	,	1.259	,	1.206	,	1.144	}	,
	{	1.288	,	1.276	,	1.247	,	1.196	,	1.144	,	1.119	,	1.132	}	,
	{	1.265	,	1.229	,	1.181	,	1.147	,	1.15	,	1.232	,	1.302	}	,
	{	1.234	,	1.192	,	1.166	,	1.187	,	1.265	,	1.25	,	1.171	}	,
	{	1.212	,	1.187	,	1.204	,	1.254	,	1.208	,	1.137	,	1.097	}	,
	{	1.208	,	1.21	,	1.241	,	1.196	,	1.133	,	1.101	,	1.092	}	,
	{	1.217	,	1.233	,	1.202	,	1.143	,	1.111	,	1.103	,	1.124	}	,
	{	1.229	,	1.217	,	1.161	,	1.124	,	1.113	,	1.133	,	1.249	}	,
	{	1.23	,	1.186	,	1.141	,	1.124	,	1.135	,	1.225	,	1.263	}	,
	{	1.214	,	1.165	,	1.137	,	1.136	,	1.193	,	1.26	,	1.183	}	,
	{	1.195	,	1.155	,	1.142	,	1.167	,	1.249	,	1.205	,	1.14	}	,
	{	1.182	,	1.154	,	1.156	,	1.216	,	1.231	,	1.162	,	1.128	}	,
	{	1.175	,	1.159	,	1.181	,	1.242	,	1.193	,	1.143	,	1.13	}	,
	{	1.174	,	1.169	,	1.214	,	1.228	,	1.168	,	1.14	,	1.136	}	,
	{	1.176	,	1.185	,	1.237	,	1.203	,	1.157	,	1.144	,	1.145	}	,
	{	1.181	,	1.206	,	1.237	,	1.185	,	1.155	,	1.151	,	1.157	}	,
	{	1.19	,	1.228	,	1.225	,	1.176	,	1.159	,	1.159	,	1.185	}	,
	{	1.201	,	1.242	,	1.212	,	1.173	,	1.165	,	1.169	,	1.244	}	,
	{	1.216	,	1.246	,	1.202	,	1.175	,	1.173	,	1.187	,	1.334	}	,
	{	1.232	,	1.242	,	1.198	,	1.18	,	1.181	,	1.221	,	1.424	}	,
	{	1.247	,	1.236	,	1.197	,	1.187	,	1.192	,	1.276	,	1.489	}	,
	{	1.257	,	1.231	,	1.198	,	1.194	,	1.207	,	1.346	,	1.528	}	,
	{	1.263	,	1.227	,	1.202	,	1.202	,	1.232	,	1.415	,	1.548	}	,
	{	1.265	,	1.226	,	1.208	,	1.21	,	1.269	,	1.47	,	1.558	}	,
	{	1.265	,	1.226	,	1.214	,	1.221	,	1.317	,	1.508	,	1.563	}	,
	{	1.264	,	1.228	,	1.221	,	1.235	,	1.37	,	1.532	,	1.565	}	,
	{	1.263	,	1.232	,	1.228	,	1.254	,	1.42	,	1.546	,	1.567	} };

	double R = 287;
	if (Flow.Temperature < 0) {
		Flow.Temperature = abs(Flow.Temperature);
	}
	double T, P;
	T = Flow.Temperature;
	P = Flow.Pressure / (101325);
	P = log10(P);
	if (Flow.Temperature <= 500) {
		Flow.Viscosity = (0.1462 * 0.00001) * ((pow(Flow.Temperature,0.5)) / (1 + 112 / Flow.Temperature));
		Flow.Density = Flow.Pressure / (R * Flow.Temperature);
		Flow.Conductivity = 1.364 * Flow.Viscosity * 1000;
		Flow.Pr = 0.73;
		Flow.Cp = 0.24 * 4186;
		Flow.Gamma = 1.4;
		Flow.Cv = Flow.Cp / Flow.Gamma;
		Flow.SoundSpeed = sqrt(Flow.Gamma * R * Flow.Temperature);
		Flow.Enthalpy = Flow.Cp * Flow.Temperature;
		Flow.Z=1;
	}
	else {
		double mu_sutherland, Conductivity_o;
		mu_sutherland = (0.1462 * 0.00001) * ((pow(Flow.Temperature,0.5)) / (1 + 112 / Flow.Temperature));
		Conductivity_o = 1.364 * Flow.Viscosity * 1000;
		if (P > 2) { P = 2; }
		if (P < -4) { P = -4; }
		if (T > 15000) { T = 15000; }
		int i_req = 0, j_req = 6;
		//int i_req, j_req;
		for (int i = 0; i < 30; i++) {
			if (T < T_Table[i]) {
				i_req = i;
				break;
			}
		}
		for (int j = 0; j < 7; j++) {
			if (P > P_Table[j]) {
				j_req = j;
				break;
			}
		}

				if(T>15000)
        {
            i_req=29;
        }




		//cout << P <<" " << j_req << endl;
		//cout << P_Table[3] << " " << T_Table[4];
		double TT, PP, Interp1, Interp2;
		TT = (Flow.Temperature - T_Table[i_req - 1]) / (T_Table[i_req] - T_Table[i_req - 1]);
		PP = (P - P_Table[j_req - 1]) / (P_Table[j_req] - P_Table[j_req - 1]);
		Interp1 = H_Table[i_req - 1][j_req - 1] + PP * (H_Table[i_req - 1][j_req] - H_Table[i_req - 1][j_req - 1]);
		Interp2 = H_Table[i_req][j_req - 1] + PP * (H_Table[i_req][j_req] - H_Table[i_req][j_req - 1]);
		Flow.Enthalpy = Interp1 + (Interp2 - Interp1) * TT;

		Interp1 = Pr_Table[i_req - 1][j_req - 1] + PP * (Pr_Table[i_req - 1][j_req] - Pr_Table[i_req - 1][j_req - 1]);
		Interp2 = Pr_Table[i_req][j_req - 1] + PP * (Pr_Table[i_req][j_req] - Pr_Table[i_req][j_req - 1]);
		Flow.Pr = Interp1 + (Interp2 - Interp1) * TT;

		Interp1 = k_Table[i_req - 1][j_req - 1] + PP * (k_Table[i_req - 1][j_req] - k_Table[i_req - 1][j_req - 1]);
		Interp2 = k_Table[i_req][j_req - 1] + PP * (k_Table[i_req][j_req] - k_Table[i_req][j_req - 1]);
		Flow.Conductivity = Interp1 + (Interp2 - Interp1) * TT;

		Interp1 = mu_Table[i_req - 1][j_req - 1] + PP * (mu_Table[i_req - 1][j_req] - mu_Table[i_req - 1][j_req - 1]);
		Interp2 = mu_Table[i_req][j_req - 1] + PP * (mu_Table[i_req][j_req] - mu_Table[i_req][j_req - 1]);
		Flow.Viscosity = Interp1 + (Interp2 - Interp1) * TT;

		Interp1 = Z_Table[i_req - 1][j_req - 1] + PP * (Z_Table[i_req - 1][j_req] - Z_Table[i_req - 1][j_req - 1]);
		Interp2 = Z_Table[i_req][j_req - 1] + PP * (Z_Table[i_req][j_req] - Z_Table[i_req][j_req - 1]);
		Flow.Z = Interp1 + (Interp2 - Interp1) * TT;

		Interp1 = Cp_Table[i_req - 1][j_req - 1] + PP * (Cp_Table[i_req - 1][j_req] - Cp_Table[i_req - 1][j_req - 1]);
		Interp2 = Cp_Table[i_req][j_req - 1] + PP * (Cp_Table[i_req][j_req] - Cp_Table[i_req][j_req - 1]);
		Flow.Cp = Interp1 + (Interp2 - Interp1) * TT;

		Interp1 = G_Table[i_req - 1][j_req - 1] + PP * (G_Table[i_req - 1][j_req] - G_Table[i_req - 1][j_req - 1]);
		Interp2 = G_Table[i_req][j_req - 1] + PP * (G_Table[i_req][j_req] - G_Table[i_req][j_req - 1]);
		Flow.Gamma = Interp1 + (Interp2 - Interp1) * TT;

		double A2;
		Interp1 = A2_Table[i_req - 1][j_req - 1] + PP * (A2_Table[i_req - 1][j_req] - A2_Table[i_req - 1][j_req - 1]);
		Interp2 = A2_Table[i_req][j_req - 1] + PP * (A2_Table[i_req][j_req] - A2_Table[i_req][j_req - 1]);
		A2 = Interp1 + (Interp2 - Interp1) * TT;

		//Flow.Viscosity = Flow.Viscosity * mu_sutherland;
		Flow.Density = Flow.Pressure / (Flow.Z * R * Flow.Temperature);
		Flow.Density = Flow.Pressure / (Flow.Z * R * T);
		//Flow.Conductivity = 1.364 * Flow.Viscosity * 1000 * Flow.Conductivity;
		//Flow.Cp = Flow.Cp * R;
		Flow.Cv = Flow.Cp / Flow.Gamma;
		//Flow.SoundSpeed = sqrt((Flow.Pressure * A2) / Flow.Density);
		//Flow.Enthalpy = Flow.Enthalpy * R * Flow.Temperature;
		Flow.SoundSpeed = sqrt(Flow.Gamma * R * Flow.Temperature);
		Flow.SoundSpeed = sqrt(Flow.Gamma *Flow.Pressure/Flow.Density);
		//cout << P << " " << j_req << " " << T << " " << i_req << " " << Flow.Gamma << " " << Flow.Cp <<  endl;
	}

}



// Get Freestream properties (P,T,rho,Z,Gamma,Pr,k,mu,Cp,Mach,Velocity,Kn)
void Compute_Freestream_Properties(struct Trajectory& Traj, Properties& Freestream, double Reference_length, struct Input_Flag Input_Flag)
{

	Traj.Altitude = Traj.Altitude / 1000;

	ISA_Nominal(Traj, Freestream);
	if(Input_Flag.Mach_input==0)
    {
    Freestream.Velocity = Traj.Velocity;
	Freestream.Mach = Freestream.Velocity / Freestream.SoundSpeed;
    }
     else if(Input_Flag.Mach_input==1)
     {
     Freestream.Mach = Traj.Mach_Number;
     Freestream.Velocity = Freestream.Mach * Freestream.SoundSpeed ;
     }
	Hansen(Freestream);


    Freestream.Knudsen_number = (Freestream.Viscosity * sqrt((0.5 * M_PI) / (287 * Freestream.Temperature))) / (Reference_length * Freestream.Density);

}



// Compute Total and After shock properties (Ideal gas)
void Compute_Downstream_Properties_Ideal(Properties& Freestream, Properties& Downstream_Ideal, double& Theta, Properties& Downstream_Total, double& Reference_length)
{
	Hansen(Freestream);
	Freestream.Velocity = Freestream.Mach * Freestream.SoundSpeed;
	Freestream.Knudsen_number = (Freestream.Mach * sqrt((0.5 * M_PI) / (287 * Freestream.Temperature))) / (Reference_length * Freestream.Density);

	double A, B, C, Beta;
	if (Freestream.Mach < 1)
	{
		Downstream_Ideal.Mach = Freestream.Mach;
		Downstream_Ideal.Pressure = Freestream.Pressure;
		Downstream_Ideal.Density = Freestream.Density;
		Downstream_Ideal.Temperature = Freestream.Temperature;
		Hansen(Downstream_Ideal);
		Downstream_Total.Temperature = Downstream_Ideal.Temperature * (1 + 0.5 * (Downstream_Ideal.Gamma - 1) * pow(Downstream_Ideal.Mach, 2));
		Downstream_Total.Pressure = Downstream_Ideal.Pressure * (pow((1 + 0.5 * (Downstream_Ideal.Gamma - 1) * pow(Downstream_Ideal.Mach, 2)), (Downstream_Ideal.Gamma / (Downstream_Ideal.Gamma - 1))));
		Hansen(Downstream_Total);
		Downstream_Total.Knudsen_number = Freestream.Knudsen_number * (Downstream_Total.Viscosity / Freestream.Viscosity) * (Freestream.SoundSpeed / Downstream_Total.SoundSpeed) * (Freestream.Density / Downstream_Total.Density);

	}
	else {
		if (Theta > 0) {
			C = 2 / ((Freestream.Gamma - 1) * tan(Theta) * (pow(Freestream.Mach, 2) + 2 / (Freestream.Gamma - 1)));
			B = (((Freestream.Gamma + 1) / (Freestream.Gamma - 1)) * pow(Freestream.Mach, 2) + (2 / (Freestream.Gamma - 1)));
			A = C * (1 - pow(Freestream.Mach, 2));
			double P, Q, S;
			P = -pow(A, 2) / 3 + B;
			Q = (2 * pow(A, 3)) / 27 - (A * B) / 3 + C;
			S = pow(P / 3, 3) + pow(Q / 2, 2);
			if (S < 0)
			{
				double A1, B1;
				B1 = sqrt(-P / 3);
				A1 = -Q / (2 * pow(B1, 3));
				A1 = acos(A1);
				double Z1, Z2, Z3;
				Z1 = 2 * B1 * cos(A1 / 3) - A / 3;
				Z2 = -2 * B1 * cos(A1 / 3 + M_PI / 3) - A / 3;
				Z3 = -2 * B1 * cos(A1 / 3 - M_PI / 3) - A / 3;
				double num[3], desc;
				num[0] = Z1;
				num[1] = Z2;
				num[2] = Z3;
				int i, j;
				for (i = 0; i < 3; ++i)   //  'for' loop is used for sorting the numbers in descending order
				{
					for (j = i + 1; j < 3; ++j)
					{
						if (num[i] < num[j])
						{
							desc = num[i];
							num[i] = num[j];
							num[j] = desc;
						}
					}
				}
				if (num[0] < 0) {
					Beta = M_PI / 2;
				}
				else {
					Beta = atan(num[1]);
				}


			}
			else {
				double A1, B1, Z1;
				A1 = sqrt(S) - Q / 2;
				B1 = -sqrt(S) - Q / 2;
				Z1 = pow(A1, 1 / 3) + pow(B1, 1 / 3) - A / 3;
				Beta = atan(Z1);
				if (Beta >= 0) {
					Beta = Beta;
				}
				else {
					Beta = M_PI / 2;
				}

			}
		}
		else {
			Beta = M_PI / 2;
		}
		double M_sinbeta, G;
		M_sinbeta = Freestream.Mach * sin(Beta);
		G = Freestream.Gamma;

		Downstream_Ideal.Mach = sqrt(((((G - 1) * pow(M_sinbeta, 2) + 2) / (2 * G * pow(M_sinbeta, 2) - (G - 1))) / sin(Beta - Theta)));

		//Downstream_Ideal.Pressure = Freestream.Pressure * ((2 * G * pow(M_sinbeta, 2) - (G - 1)) / (G + 1));
        double T_ratio,P_ratio,rho_ratio;
		P_ratio = ((2 * G * pow(M_sinbeta, 2) - (G - 1)) / (G + 1));
		Downstream_Ideal.Pressure = Freestream.Pressure * P_ratio;


		Downstream_Ideal.Density = Freestream.Density * (((G + 1) * pow(M_sinbeta, 2)) / ((G - 1) * pow(M_sinbeta, 2) + 2));


		P_ratio = ((2*G)/(G+1))*(pow(M_sinbeta, 2) - (G-1));
		rho_ratio= (((G + 1) * pow(M_sinbeta, 2)) / ((G - 1) * pow(M_sinbeta, 2) + 2));

		//T_ratio = ((2 * G * pow(M_sinbeta, 2) - (G - 1)) / (G + 1)) / (((G + 1) * pow(M_sinbeta, 2)) / ((G - 1) * pow(M_sinbeta, 2) + 2));

		T_ratio = P_ratio / rho_ratio;

		Downstream_Ideal.Temperature = Freestream.Temperature * T_ratio;

		Hansen(Downstream_Ideal);

		Downstream_Total.Temperature = Downstream_Ideal.Temperature * (1 + 0.5 * (Downstream_Ideal.Gamma - 1) * pow(Downstream_Ideal.Mach, 2));
		Downstream_Total.Temperature = Freestream.Temperature * (1 + 0.5 * (Freestream.Gamma - 1) * pow(Freestream.Mach, 2));

		Downstream_Total.Pressure = Downstream_Ideal.Pressure * (pow((1 + 0.5 * (Downstream_Ideal.Gamma - 1) * pow(Downstream_Ideal.Mach, 2)), (Downstream_Ideal.Gamma / (Downstream_Ideal.Gamma - 1))));
		Hansen(Downstream_Total);
		Downstream_Total.Knudsen_number = Freestream.Knudsen_number * (Downstream_Total.Viscosity / Freestream.Viscosity) * (Freestream.SoundSpeed / Downstream_Total.SoundSpeed) * (Freestream.Density / Downstream_Total.Density);

	}

}


// Compute Total and After shock properties (Real gas)
void Compute_Downstream_Properties_Real(Properties& Freestream, Properties& Downstream_Ideal, Properties& Downstream_Real, Properties& Downstream_Total, double& Theta, double Reference_length)
{
	Hansen(Freestream);
	Freestream.Velocity = Freestream.Mach * Freestream.SoundSpeed;
	Freestream.Knudsen_number = (Freestream.Mach * sqrt((0.5 * M_PI) / (287 * Freestream.Temperature))) / (Reference_length * Freestream.Density);
	if (Freestream.Mach < 1) {
		Downstream_Real.Temperature = Freestream.Temperature;
		Downstream_Real.Pressure = Freestream.Pressure;
		Downstream_Real.Density = Freestream.Density;
		Downstream_Real.Gamma = Freestream.Gamma;
		Downstream_Real.Mach = Freestream.Mach;
		Downstream_Real.Velocity = Freestream.Velocity;
		Downstream_Real.Knudsen_number = Freestream.Knudsen_number;
	}

	else {

		double Momentum_Total, MassFlow_Rate;
		MassFlow_Rate = Freestream.Density * Freestream.Velocity;
		Momentum_Total = Freestream.Pressure + Freestream.Density * pow(Freestream.Velocity, 2);
		Compute_Downstream_Properties_Ideal(Freestream, Downstream_Ideal, Theta, Downstream_Total, Reference_length);
		Downstream_Real.Density = Downstream_Ideal.Density;
		Downstream_Real.Temperature = Downstream_Ideal.Temperature;
		Downstream_Total.Enthalpy = Freestream.Enthalpy + 0.5 * pow(Freestream.Velocity, 2);
		double iter_outer, iter_inner, del_Temp, del_H, H_old, rho_old, del_rho;
		iter_outer = 0;

		del_rho = 1;


		while (del_rho > 0.02 && iter_outer < 11) {
			Downstream_Real.Velocity = MassFlow_Rate / Downstream_Real.Density;
			Downstream_Real.Pressure = Momentum_Total - Downstream_Real.Density * pow(Downstream_Real.Velocity, 2);
			Downstream_Real.Enthalpy = Downstream_Total.Enthalpy - 0.5 * pow(Downstream_Real.Velocity, 2);
			H_old = Downstream_Real.Enthalpy;
			rho_old = Downstream_Real.Density;
			iter_inner = 0;

			del_H = 1;
			  while ((abs(del_H) > 0.01) && (iter_inner < 51)) {
				Hansen(Downstream_Real);

				del_Temp = ((Downstream_Real.Enthalpy - H_old) / Downstream_Real.Cp);
				if (del_Temp / Downstream_Real.Temperature > 0.3) {
					del_Temp = 0.3 * Downstream_Real.Temperature;
				}
				del_H = ((H_old - Downstream_Real.Enthalpy) / H_old);
				Downstream_Real.Temperature = Downstream_Real.Temperature - del_Temp;

				iter_inner = iter_inner + 1;

			}
			Downstream_Real.Density = (Downstream_Real.Density + rho_old) / 2;
			del_rho = abs((Downstream_Real.Density - rho_old) / rho_old);
			iter_outer = iter_outer + 1;

		}

		Downstream_Real.Mach = Downstream_Real.Velocity / Downstream_Real.SoundSpeed;
		Downstream_Real.Knudsen_number = Freestream.Knudsen_number * (Downstream_Real.Viscosity / Freestream.Viscosity) * (Freestream.SoundSpeed / Downstream_Real.SoundSpeed) * (Freestream.Density / Downstream_Real.Density);

	}
	Downstream_Total.Temperature = Downstream_Real.Temperature * (1 + 0.5 * (Downstream_Real.Gamma - 1) * pow(Downstream_Real.Mach, 2));
	Downstream_Total.Pressure = Downstream_Real.Pressure * (pow((1 + 0.5 * (Downstream_Real.Gamma - 1) * pow(Downstream_Real.Mach, 2)), (Downstream_Real.Gamma / (Downstream_Real.Gamma - 1))));
	Hansen(Downstream_Total);
	Downstream_Total.Knudsen_number = Freestream.Knudsen_number * (Downstream_Total.Viscosity / Freestream.Viscosity) * (Freestream.SoundSpeed / Downstream_Total.SoundSpeed) * (Freestream.Density / Downstream_Total.Density);

}



// Compute Cp at a given location and Mach number
void Compute_Cp(double &Coefficient_of_Pressure, struct Input_Flag &Input_Flag, Properties &Freestream, double Analysis_Location, int No_of_lines_Location, int No_of_lines_Mach, double M_Table[], double Location_Table[], MatrixXd COP_Table)
//void Compute_Cp(double &Coefficient_of_Pressure, struct Input_Flag &Input_Flag, Properties &Freestream, double Analysis_Location, int No_of_lines_Location, int No_of_lines_Mach, double M_Table[], double Location_Table[], vector<vector<double>> COP_Table)
{

	if (Input_Flag.Inviscid_Flag == 2) {
		double Minf;
		Minf = Freestream.Mach;
		if (Freestream.Mach > 30)
		{
			Minf = 30;
		}
		int ii_req, jj_req;
		for (int jj = 0; jj < No_of_lines_Mach; jj++) {
			if (M_Table[jj] > Freestream.Mach) {
				jj_req = jj;
				break;
			}
			else {
				jj_req = No_of_lines_Mach-1;
			}
		}
		for (int ii = 0; ii < No_of_lines_Location; ii++) {
			if (Location_Table[ii] > Analysis_Location) {
				ii_req = ii;
				break;
			}
			else {
				ii_req = No_of_lines_Location-1;
			}
		}

		double Loc, MM, COP_Interp1, COP_Interp2;
		Loc = (Analysis_Location - Location_Table[ii_req - 1]) / (Location_Table[ii_req] - Location_Table[ii_req - 1]);
		MM = (Minf - M_Table[jj_req - 1]) / (M_Table[jj_req] - M_Table[jj_req - 1]);


		COP_Interp1 = COP_Table(ii_req - 1,jj_req - 1) + Loc * (COP_Table(ii_req,jj_req - 1) - COP_Table(ii_req - 1,jj_req - 1));
		COP_Interp2 = COP_Table(ii_req - 1,jj_req) + Loc * (COP_Table(ii_req,jj_req) - COP_Table(ii_req - 1,jj_req));

		Coefficient_of_Pressure = COP_Interp1 + (COP_Interp2 - COP_Interp1) * MM;

	}
	else
    {
        Coefficient_of_Pressure=0;
    }

}


//Compute Edge properties after computing Edge temperature and Edge pressure
void Compute_Properties_Edge(Properties& Freestream, Properties& Downstream_Ideal, Properties& Downstream_Real, Properties& Downstream_Total, Properties& Edge, struct Input_Flag& Input_Flag, double Coefficient_of_Pressure,double Theta, double Reference_length)
{
    Properties Downstream_Total_Ideal;
    Compute_Downstream_Properties_Ideal(Freestream, Downstream_Ideal, Theta, Downstream_Total_Ideal, Reference_length);
	if (Input_Flag.Inviscid_Flag == 0) {
		Edge.Pressure = Freestream.Pressure;
		Edge.Mach = sqrt((2 * (pow((Downstream_Total.Pressure / Edge.Pressure), ((Freestream.Gamma - 1) / Freestream.Gamma)) - 1)) / (Freestream.Gamma - 1));
		Edge.Temperature = Downstream_Total.Temperature / (1 + 0.5 * (Freestream.Gamma - 1) * pow(Edge.Mach, 2));
	}
	else {
		double FACTOR, Gamma, Pressure_Ratio;
		Gamma = 1.405;
		Pressure_Ratio = Downstream_Ideal.Pressure / Freestream.Pressure;

		FACTOR = (1 + ((Gamma) / 2) * Freestream.Mach * Freestream.Mach * Coefficient_of_Pressure) / Pressure_Ratio;
		if (FACTOR < 0) {
			FACTOR = 1 / Pressure_Ratio;
		}
		FACTOR = pow(FACTOR, ((Gamma - 1) / Gamma));
		FACTOR = (1 + (0.5 * (Gamma - 1) * Downstream_Ideal.Mach * Downstream_Ideal.Mach)) / FACTOR;
		Edge.Mach = sqrt((FACTOR - 1) / (0.5 * (Gamma - 1)));
		Edge.Temperature = Downstream_Total.Temperature / (1 + 0.5 * (Freestream.Gamma - 1) * pow(Edge.Mach, 2));
		Edge.Pressure = Downstream_Total.Pressure / (pow((1 + 0.5 * (Freestream.Gamma - 1) * pow(Edge.Mach, 2)), (Freestream.Gamma / (Freestream.Gamma - 1))));

	}
	Hansen(Edge);
	Edge.Velocity = Edge.Mach * Edge.SoundSpeed;
}


//Compute wall properties using wall temperature & Edge pressure (for flat plate), total pressure (for stagnation)
void Compute_Properties_wall(Properties& Freestream, Properties& Downstream_Ideal, Properties& Downstream_Real, Properties& Edge, Properties& Downstream_Total, Properties& wall, double Running_length)
{

	if(Running_length==0)
    {
        wall.Pressure = Downstream_Total.Pressure;
    }
	else{
        wall.Pressure = Edge.Pressure;
	}

	Hansen(wall);
}

//Compute various kinds of heat flux and realte parameters (Cf,Ch,rec,RAF, etc)
struct Heat_Flux_Convective
{
	double q_Stagnation;
	double q_laminar;
	double q_turbulent;
	double q_Flat_Plate;
	double q_aero_net;
	double q_FreeMolecular;
	double q_slip;
	double h_laminar;
	double h_turbulent;
	double Ch_laminar;
	double Ch_turbulent;
	double Cf_laminar;
	double Cf_turbulent;
	double rec_laminar;
	double rec_turbulent;
	double RAF_laminar;
	double RAF_turbulent;
	double Cf_net;
	double Ch;
	double q_Lees_spherical;
	double q_Lees_Conical;
	double q_continum;
};


//Compare Re criteria for transition
void Transition_Re(int Transition_based_on_Retheta,double &Re_transition_criteria, double &Rey_No_Edge1, double Re_transition, Properties Edge,struct Heat_Flux_Convective &Heat_Flux_Convective)
{
    if(Transition_based_on_Retheta==1)
    {
      Re_transition_criteria= Re_transition;
      Rey_No_Edge1=Edge.Rey_No*0.5*Heat_Flux_Convective.Cf_laminar ;
    }
    else
    {
        Re_transition_criteria= Re_transition;
        Rey_No_Edge1=Edge.Rey_No;
    }
}


// Get Running Length at analysis location
void Body(double COMPONENT_RADIUS[], double COMPONENT_THETA[], double COMPONENT_LENGTH[], double Analysis_Location, double &Running_length,  struct Input_Flag Input_Flag, double &IC)
{
	int No_of_components;
	No_of_components = Input_Flag.No_of_components;
	double X1, Y1, S1;
	X1 = Analysis_Location;

	double RADIUS[No_of_components + 2], THETA[No_of_components + 2], LENGTH[No_of_components + 2];


	RADIUS[0] = 0;
	THETA[0] = 0;
	LENGTH[0] = 0;

	RADIUS[1] = 0;
	THETA[1] = M_PI / 2;
	LENGTH[1] = 0;


	for (int i = 1; i <= No_of_components; i++)
	{


		RADIUS[i + 1] = COMPONENT_RADIUS[i-1];
		THETA[i + 1] = COMPONENT_THETA[i-1];
		LENGTH[i + 1] = COMPONENT_LENGTH[i-1];

	}


	int NC;

	No_of_components = No_of_components + 1;
	NC = 2 * No_of_components;

	double X[NC + 1], Y[NC + 1], S[NC + 1], XC[NC + 1], YC[NC + 1];
	int SIGN;
	double THC;
	X[0] = 0;
	Y[0] = 0;
	Y[0] = 0;
	X[1] = 0;
	Y[1] = 0;
	S[1] = 0;
	X[2] = 0;
	Y[2] = 0;
	S[2] = 0;
   XC[0]=0;
   YC[0]=0;
   XC[1]=0;
   YC[1]=0;
	for (int i = 2; i <= No_of_components; i++)
	{
		SIGN = 1;
		if (THETA[i] > THETA[i - 1])
		{
			SIGN = -1;
		}

		XC[i] = X[2 * i - 2] + RADIUS[i] * sin(THETA[i - 1]) * SIGN;
		YC[i] = Y[2 * i - 2] - RADIUS[i] * cos(THETA[i - 1]) * SIGN;
		X[2 * i - 1] = XC[i] - RADIUS[i] * sin(THETA[i]) * SIGN;
		Y[2 * i - 1] = YC[i] + RADIUS[i] * cos(THETA[i]) * SIGN;
		S[2 * i - 1] = S[2 * i - 2] + RADIUS[i] * abs(THETA[i] - THETA[i - 1]);
		X[2 * i] = X[2 * i - 1] + LENGTH[i];
		Y[2 * i] = Y[2 * i - 1] + LENGTH[i] * tan(THETA[i]);
		S[2 * i] = S[2 * i - 1] + LENGTH[i] / cos(THETA[i]);




	}




	if (X1 == 0)
	{
		Y1 = 0;
		S1 = 0;
		THC = M_PI / 2;
	}
	else
	{
		//
		int K, KK;
		for (int I = 3; I <= NC; I++)
		{
			if (X1 <= X[I])
			{

				K = I;
				break;
			}
		}


		// K=I;
		KK = K / 2;


		if (2*KK == K)
		{
			//for flat part
			double FACT;
			FACT = (X1 - X[K - 1]) / (X[K] - X[K - 1]);
			Y1 = Y[K - 1] + FACT * (Y[K] - Y[K - 1]);
			S1 = S[K - 1] + (S[K] - S[K - 1]) * FACT;
			THC = THETA[KK];
			IC = 1 * Input_Flag.Axisymmetric;
			if (THETA[KK] <= 0)
			{
				IC = 0;
			}


		}
		else
		{
			//for sphere
			double DY, TANDTH, DTH;
			DY = 1;
			SIGN = 1;
			if (THETA[KK + 1] > THETA[KK])
			{
				SIGN = -1;
			}
			Y1 = YC[KK + 1] + DY * SIGN;
			TANDTH = (((Y[K - 1] - YC[KK + 1]) * (X1 - XC[KK + 1])) - (Y1 - YC[KK + 1]) * (X[K - 1] - XC[KK + 1])) / (((X1 - XC[KK + 1]) * (X[K - 1] - XC[KK + 1])) + ((Y1 - YC[KK + 1]) * (Y[K - 1] - YC[KK + 1])));
			DTH = atan(TANDTH);
			S1 = S[K - 1] + RADIUS[KK + 1] * abs(DTH);
			THC = (S1 - S[K - 1]) / RADIUS[KK + 1];
			THC = THETA[KK] - THC * SIGN;
			IC = 1 * Input_Flag.Axisymmetric;


		}
	}


	Running_length=S1;

}


// Fay & Ridell (Stagnation heating) and Beckwith Gallaghar (Stagnation heating,Yawed cylinder)
void Stagnation_Heating(struct Heat_Flux_Convective& HF_Convective, Properties& Downstream_Total, Properties& wall, Properties& Freestream, Properties& Downstream_Ideal, struct Input_Flag& Input_Flag, Geometry& Component_1, double &Temperature_recovery)
{
	double Dissociation_Enthalpy;
	double P_N2, P_O2, T_N2, T_O2, E_N2, E_O2, F_N2, F_O2, PO, TO;
	PO = Downstream_Total.Pressure / 101325;
	TO = Downstream_Total.Temperature;
	Temperature_recovery=Downstream_Total.Temperature ;
	P_N2 = 4.5 * pow(10, 7);
	P_O2 = 2.3 * pow(10, 7);
	T_N2 = 113200;
	T_O2 = 59000;
	F_N2 = (P_N2 / PO) * (TO / T_N2) * exp(-T_N2 / TO);
	F_O2 = (P_O2 / PO) * (TO / T_O2) * exp(-T_O2 / TO);
	E_N2 = 4183;
	E_O2 = 7023;
	Dissociation_Enthalpy = 4186 * (0.79 * E_N2 * sqrt(F_N2 / (F_N2 + 1)) + 0.21 * E_O2 * sqrt(F_O2 / (F_O2 + 1)));
	double Fay_Factor, Lewis_No, beta;
	beta = 0.63;
	Lewis_No = 1.4;
	Fay_Factor = pow(Downstream_Total.Pr, -0.6) * pow((wall.Density * wall.Viscosity), 0.1) * pow((Downstream_Total.Density * Downstream_Total.Viscosity), 0.4) * (Downstream_Total.Enthalpy - wall.Enthalpy) * (1 + (pow(Lewis_No, beta) - 1) * (Dissociation_Enthalpy / Downstream_Total.Enthalpy));

	double DuDx;
	if (Input_Flag.Axisymmetric == 1 && Input_Flag.Geometry == 1)
	{
		DuDx = (0.3 * Freestream.Velocity) / (2 * Component_1.Radius);
		HF_Convective.q_Stagnation = 0.763 * Fay_Factor * sqrt(DuDx);

	}
	else if (Input_Flag.Axisymmetric == 1 && Input_Flag.Geometry == 2)
	{
		DuDx = (1 / Component_1.Radius) * sqrt((2 * (Downstream_Total.Pressure - Freestream.Pressure)) / Downstream_Total.Density);
		HF_Convective.q_Stagnation = 0.763 * Fay_Factor * sqrt(DuDx);

	}
	else if (Input_Flag.Axisymmetric == 1 && Input_Flag.Geometry == 3)
	{
		DuDx = (1 / Component_1.Radius) * sqrt((2 * (Downstream_Total.Pressure - Freestream.Pressure)) / Downstream_Total.Density);
		HF_Convective.q_Stagnation = 0.763 * Fay_Factor * sqrt(DuDx);
	}
	else if (Input_Flag.Axisymmetric == 0 && Input_Flag.Geometry == 1)
	{
		DuDx = (0.3 * Freestream.Velocity) / (2 * Component_1.Radius);
		HF_Convective.q_Stagnation = 0.57 * Fay_Factor * sqrt(DuDx);
	}
	else if (Input_Flag.Axisymmetric == 0 && Input_Flag.Geometry == 2)
	{
		DuDx = (1 / Component_1.Radius) * sqrt((2 * (Downstream_Total.Pressure - Freestream.Pressure)) / Downstream_Total.Density);
		HF_Convective.q_Stagnation = 0.57 * Fay_Factor * sqrt(DuDx);
	}
	else if (Input_Flag.Axisymmetric == 0 && Input_Flag.Geometry == 3)
	{
		Freestream.Rey_No = (Freestream.Density * Freestream.Velocity * 2 * Component_1.Radius) / Freestream.Viscosity;

		if (Freestream.Mach < 1) {
			Downstream_Ideal.Mach = Freestream.Mach * cos(Component_1.Lambda);
			Downstream_Ideal.Pressure = Freestream.Pressure;
			Downstream_Total.Temperature = Freestream.Temperature * (1 + 0.5 * (Freestream.Gamma - 1) * pow(Freestream.Mach * cos(Component_1.Lambda), 2));
			Downstream_Total.Pressure = Downstream_Ideal.Pressure * (pow((1 + 0.5 * (Freestream.Gamma - 1) * pow(Freestream.Mach * cos(Component_1.Lambda), 2)), (Freestream.Gamma) / (Freestream.Gamma - 1)));
		}
		else {
			Downstream_Ideal.Mach = (1 + 0.5 * (Freestream.Gamma - 1) * pow(Freestream.Mach * cos(Component_1.Lambda), 2)) / (Freestream.Gamma * pow(Freestream.Mach * cos(Component_1.Lambda), 2) - 0.5 * (Freestream.Gamma - 1));
			Downstream_Ideal.Mach = sqrt(Downstream_Ideal.Mach);
			Downstream_Ideal.Pressure = Freestream.Pressure * (1 + ((2 * Freestream.Gamma) / (Freestream.Gamma + 1)) * (pow(Freestream.Mach * cos(Component_1.Lambda), 2) - 1));
			Downstream_Total.Temperature = Freestream.Temperature * (1 + 0.5 * (Freestream.Gamma - 1) * pow(Freestream.Mach * cos(Component_1.Lambda), 2));
			Downstream_Total.Pressure = Downstream_Ideal.Pressure * (pow((1 + 0.5 * (Freestream.Gamma - 1) * pow(Downstream_Ideal.Mach , 2)), (Freestream.Gamma) / (Freestream.Gamma - 1)));

		}
		Hansen(Downstream_Total);

	//	HF_Convective.h_laminar = 0.5 * sqrt(2 * (Freestream.Rey_No / Freestream.Mach) * (Downstream_Total.Viscosity / Freestream.Viscosity)) * (pow((2 / Freestream.Gamma) * (Freestream.Temperature / Downstream_Total.Temperature) * (Downstream_Total.Pressure / Freestream.Pressure) * ((Downstream_Total.Pressure / Freestream.Pressure) - 1), 0.25)) * cos(Component_1.Lambda);

		HF_Convective.h_laminar = 0.5 * sqrt(2 * (Freestream.Rey_No / Freestream.Mach) * (Downstream_Total.Viscosity / Freestream.Viscosity)) * (pow((2 /Downstream_Total.Gamma) * (Freestream.Temperature / Downstream_Total.Temperature) * (Downstream_Total.Pressure / Freestream.Pressure) * ((Downstream_Total.Pressure / Freestream.Pressure) - 1), 0.25)) ;

		HF_Convective.h_laminar = HF_Convective.h_laminar * (Freestream.Conductivity / (2 * Component_1.Radius));
		HF_Convective.rec_laminar = sqrt(Downstream_Total.Pr);
		double TAW, TREC;
		TAW = Freestream.Temperature * (1 + 0.5 * (Freestream.Gamma - 1) * pow(Freestream.Mach, 2));
		TREC = HF_Convective.rec_laminar * (TAW - Downstream_Total.Temperature) + Downstream_Total.Temperature;
		HF_Convective.q_laminar = HF_Convective.h_laminar * (TREC - wall.Temperature);
		HF_Convective.q_Stagnation = HF_Convective.q_laminar ;
		//cout << TREC << endl;
	}
	else if (Input_Flag.Axisymmetric == 0 && Input_Flag.Geometry == 4)
	{
		Freestream.Rey_No = (Freestream.Density * Freestream.Velocity * 2 * Component_1.Radius) / Freestream.Viscosity;
		if (Freestream.Mach < 1) {
			Downstream_Ideal.Mach = Freestream.Mach * cos(Component_1.Lambda);
			Downstream_Ideal.Pressure = Freestream.Pressure;
			Downstream_Total.Temperature = Freestream.Temperature * (1 + 0.5 * (Freestream.Gamma - 1) * pow(Freestream.Mach * cos(Component_1.Lambda), 2));
			Downstream_Total.Pressure = Downstream_Ideal.Pressure * (pow((1 + 0.5 * (Freestream.Gamma - 1) * pow(Freestream.Mach * cos(Component_1.Lambda), 2)), (Freestream.Gamma) / (Freestream.Gamma - 1)));
		}
		else {
			Downstream_Ideal.Mach = (1 + 0.5 * (Freestream.Gamma - 1) * pow(Freestream.Mach * cos(Component_1.Lambda), 2)) / (Freestream.Gamma * pow(Freestream.Mach * cos(Component_1.Lambda), 2) - 0.5 * (Freestream.Gamma - 1));
			Downstream_Ideal.Mach = sqrt(Downstream_Ideal.Mach);
			Downstream_Ideal.Pressure = Freestream.Pressure * (1 + ((2 * Freestream.Gamma) / (Freestream.Gamma + 1)) * (pow(Freestream.Mach * cos(Component_1.Lambda), 2) - 1));
			Downstream_Total.Temperature = Freestream.Temperature * (1 + 0.5 * (Freestream.Gamma - 1) * pow(Freestream.Mach * cos(Component_1.Lambda), 2));
			Downstream_Total.Pressure = Downstream_Ideal.Pressure * (pow((1 + 0.5 * (Freestream.Gamma - 1) * pow(Downstream_Ideal.Mach, 2)), (Freestream.Gamma) / (Freestream.Gamma - 1)));

		}

		Hansen(Downstream_Total);
		DuDx = (1 / Component_1.Radius) * sqrt((2 * (Downstream_Total.Pressure - Freestream.Pressure)) / Downstream_Total.Density);


		double TAW, TREC;
		TAW = Freestream.Temperature * (1 + 0.5 * (Freestream.Gamma - 1) * pow(Freestream.Mach, 2));
		Properties Beckwith_Turbulent;
		Beckwith_Turbulent.Temperature = TAW;
		//Confirm with Sir
		Beckwith_Turbulent.Pressure = Downstream_Total.Pressure;
		Hansen(Beckwith_Turbulent);

		HF_Convective.rec_turbulent = pow(Downstream_Total.Pr, 0.333333333333333);
		HF_Convective.h_turbulent = HF_Convective.rec_turbulent * pow((Freestream.Rey_No * 0.0228 * (Downstream_Total.Pressure / Freestream.Pressure) * (wall.Viscosity / Beckwith_Turbulent.Viscosity) * (Freestream.Temperature / wall.Temperature)), 0.8) * pow(sin(Component_1.Lambda), 0.6) * pow((0.130319149) * (Beckwith_Turbulent.Viscosity / Freestream.Viscosity) * cos(Component_1.Lambda) * DuDx * ((2 * Component_1.Radius) / Freestream.Velocity), 0.2);
		HF_Convective.h_turbulent = HF_Convective.h_turbulent * (Freestream.Conductivity / (2 * Component_1.Radius));

//////additional line as per OTAP
		//HF_Convective.rec_turbulent=max(HF_Convective.rec_turbulent,HF_Convective.rec_laminar);
		//HF_Convective.h_turbulent=max(HF_Convective.h_turbulent,HF_Convective.h_laminar);
//////////////////////////////

		TREC = HF_Convective.rec_turbulent * (TAW - Downstream_Total.Temperature) + Downstream_Total.Temperature;
		HF_Convective.q_turbulent = HF_Convective.h_turbulent * (TREC - wall.Temperature);

		HF_Convective.q_Stagnation = HF_Convective.q_turbulent ;

	}
}


// Eckert & Van driest (Flat regime heating)
void Flat_Plate_Heating(struct Heat_Flux_Convective& HF_Convective, Properties& Downstream_Total, Properties& wall, Properties& Freestream, Properties& Downstream_Ideal, Properties& Downstream_Real, Properties& Edge, struct Input_Flag& Input_Flag, double Analysis_Location, double Running_length, double &Re_transition, double RETS, double &Re_transition_criteria, double &Rey_No_Edge1, int Transition_based_on_Retheta,double &Temperature_Recovery)
{
	Hansen(Edge);
	Edge.Velocity = Edge.Mach * Edge.SoundSpeed;

	//Body(Geometry, Analysis_Location, Running_length);
	Edge.Rey_No = (Running_length * Edge.Velocity * Edge.Density) / Edge.Viscosity;
	double Hrecovery, Trecovery, Shear;




	if (Input_Flag.VanDriest == 1 &&  Input_Flag.Full_turbulent == 0)
	{
		double F1, F2, Re_corrected;
		Re_corrected = Edge.Rey_No / (2 * Input_Flag.Is_Cone + 1);
		F1 = 0.416594 - 0.246733 * 0.01 * Edge.Mach - 0.817489 * 0.001 * pow(Edge.Mach, 2) + 0.2734033 * 0.0001 * pow(Edge.Mach, 3);
		F2 = -0.134671 * 0.1 + 0.2635807 * 0.001 * Edge.Mach + 0.581944 * .0001 * pow(Edge.Mach, 2) - 0.2173257 * 0.00001 * pow(Edge.Mach, 3);
		HF_Convective.Ch_laminar = (F1 + F2 * (wall.Temperature / Edge.Temperature)) / (sqrt(Re_corrected));
		HF_Convective.rec_laminar = sqrt(Edge.Pr);
		HF_Convective.RAF_laminar = pow(Edge.Pr, 2 / 3);
		HF_Convective.Cf_laminar = 2 * HF_Convective.RAF_laminar * HF_Convective.Ch_laminar;
		Hrecovery = Edge.Enthalpy + 0.5 * Edge.Velocity * Edge.Velocity * HF_Convective.rec_laminar;
		HF_Convective.q_laminar = HF_Convective.Ch_laminar * Edge.Density * Edge.Velocity * (Hrecovery - wall.Enthalpy);
		Shear = 0.5 * Edge.Density * Edge.Velocity * Edge.Velocity * HF_Convective.Cf_laminar;
		HF_Convective.q_Flat_Plate = HF_Convective.q_laminar ;
	}
	else if (Input_Flag.VanDriest == 1 && Input_Flag.Full_turbulent == 1)
	{
		double Re_corrected1;
		Re_corrected1 = Edge.Rey_No / (Input_Flag.Is_Cone + 1);

		double A, B, ALFA, BETA;
		A = sqrt(((Edge.Gamma - 1) * pow(Edge.Mach, 2)) / (2 * (wall.Temperature / Edge.Temperature)));
		B = ((1 + 0.5 * (Edge.Gamma - 1) * pow(Edge.Mach, 2)) / (wall.Temperature / Edge.Temperature)) - 1;
		ALFA = (2 * A * A - B) / sqrt(B * B + 4 * A * A);
		BETA = B / sqrt(B * B + 4 * A * A);
		double  C1, C2, C3, C4, n, CFS, F, FD, DELTA_CFS;
		n = 0.707;
		C1 = (n + 0.5) * log10(wall.Temperature / Edge.Temperature);
		C2 = (0.242 / (sqrt(A * A * (wall.Temperature / Edge.Temperature))))*(asin(ALFA) + asin(BETA));
		C3 = 0.41;
		DELTA_CFS = 1;
		CFS = 0.001;
		while (abs(DELTA_CFS) > 0.00001)
		{
			C4 = log10(Re_corrected1 * CFS);
			F = C2 / sqrt(CFS) - C3 - C4 + C1;
			FD = -(C2 / 2) * pow(CFS, -1.5) - log10(exp(1)) / CFS;
			DELTA_CFS = F / FD;
			CFS = CFS - DELTA_CFS;

		}
		HF_Convective.Cf_turbulent = CFS;
		double Pr_t, K, Hrecovery;
		Pr_t = 0.86;
		K = 0.4;
		double Q1, Q2, Q3, Q4, Q5;
		Q1 = (Edge.Pr / Pr_t) - 1;
		Q2 = 1 - Pr_t;
		Q3 = ((sqrt(2 * CFS) * Q2) / K) * (pow(M_PI, 2) / 6 + 1.5 * Q2);
		Q4 = 12.5 * CFS * (Q1 + 2 * log(1 + (5 / 6) * Q1) + log(6) * log(1 + (7 / 8) * Q1) - (log(1 + (1 / 4) * Q1)));
		Q5 = log(1 + (5 / 6) * Q1);
		HF_Convective.rec_turbulent = Pr_t * (1 + Q3 + Q4);
		HF_Convective.RAF_turbulent = Pr_t * (1 + 0.5 * Q3 + 5 * sqrt(0.5 * CFS) * (Q1 + Q5));
		HF_Convective.Ch_turbulent = HF_Convective.Cf_turbulent / (2 * HF_Convective.RAF_turbulent);
		Hrecovery = Edge.Enthalpy + 0.5 * Edge.Velocity * Edge.Velocity * HF_Convective.rec_turbulent;
		HF_Convective.q_turbulent = HF_Convective.Ch_turbulent * Edge.Density * Edge.Velocity * (Hrecovery - wall.Enthalpy);
		Shear = 0.5 * Edge.Density * Edge.Velocity * Edge.Velocity * HF_Convective.Cf_turbulent;
		HF_Convective.q_Flat_Plate = HF_Convective.q_turbulent ;

	}

	Transition_Re(Transition_based_on_Retheta,Re_transition_criteria,Rey_No_Edge1, Re_transition, Edge,HF_Convective);

	if (Input_Flag.VanDriest == 1 && Input_Flag.Full_turbulent == 0 && Rey_No_Edge1 >= Re_transition_criteria)
	{
		double F1, F2, Re_corrected;
		Re_corrected = Edge.Rey_No / (2 * Input_Flag.Is_Cone + 1);
		F1 = 0.416594 - 0.246733 * 0.01 * Edge.Mach - 0.817489 * 0.001 * pow(Edge.Mach, 2) + 0.2734033 * 0.0001 * pow(Edge.Mach, 3);
		F2 = -0.134671 * 0.1 + 0.2635807 * 0.001 * Edge.Mach + 0.581944 * .0001 * pow(Edge.Mach, 2) - 0.2173257 * 0.00001 * pow(Edge.Mach, 3);
		HF_Convective.Ch_laminar = (F1 + F2 * (wall.Temperature / Edge.Temperature)) / (sqrt(Re_corrected));
		HF_Convective.rec_laminar = sqrt(Edge.Pr);
		HF_Convective.RAF_laminar = pow(Edge.Pr, 2 / 3);
		HF_Convective.Cf_laminar = 2 * HF_Convective.RAF_laminar * HF_Convective.Ch_laminar;



		double Re_corrected1;
		Re_corrected1 = (Edge.Rey_No - RETS) / (Input_Flag.Is_Cone + 1);
		double A, B, ALFA, BETA;
		A = sqrt(((Edge.Gamma - 1) * pow(Edge.Mach, 2)) / (2 * (wall.Temperature / Edge.Temperature)));
		B = ((1 + 0.5 * (Edge.Gamma - 1) * pow(Edge.Mach, 2)) / (wall.Temperature / Edge.Temperature)) - 1;
		ALFA = (2 * A * A - B) / sqrt(B * B + 4 * A * A);
		BETA = B / sqrt(B * B + 4 * A * A);
		double  C1, C2, C3, C4, n, CFS, F, FD, DELTA_CFS;
		n = 0.707;
		C1 = (n + 0.5) * log10(wall.Temperature / Edge.Temperature);
		C2 = (0.242 / (sqrt(A * A * (wall.Temperature / Edge.Temperature))))*(asin(ALFA) + asin(BETA));
		C3 = 0.41;
		DELTA_CFS = 1;
		CFS = 0.001;
		while (abs(DELTA_CFS) > 0.00001)
		{
			C4 = log10(Re_corrected1 * CFS);
			F = C2 / sqrt(CFS) - C3 - C4 + C1;
			FD = -(C2 / 2) * pow(CFS, -1.5) - log10(exp(1)) / CFS;
			DELTA_CFS = F / FD;
			CFS = CFS - DELTA_CFS;
		}
		HF_Convective.Cf_turbulent = CFS;
		double Pr_t, K, Hrecovery;
		Pr_t = 0.86;
		K = 0.4;
		double Q1, Q2, Q3, Q4, Q5;
		Q1 = (Edge.Pr / Pr_t) - 1;
		Q2 = 1 - Pr_t;
		Q3 = ((sqrt(2 * CFS) * Q2) / K) * (pow(M_PI, 2) / 6 + 1.5 * Q2);
		Q4 = 12.5 * CFS * (Q1 + 2 * log(1 + (5 / 6) * Q1) + log(6) * log(1 + (7 / 8) * Q1) - (log(1 + (1 / 4) * Q1)));
		Q5 = log(1 + (5 / 6) * Q1);
		HF_Convective.rec_turbulent = Pr_t * (1 + Q3 + Q4);
		HF_Convective.RAF_turbulent = Pr_t * (1 + 0.5 * Q3 + 5 * sqrt(0.5 * CFS) * (Q1 + Q5));
		HF_Convective.Ch_turbulent = HF_Convective.Cf_turbulent / (2 * HF_Convective.RAF_turbulent);


            if(Transition_based_on_Retheta==1)
            {
                Re_transition = (0.664)/((2*Re_transition*Edge.Viscosity)/(Edge.Density*Edge.Velocity));
            }

		double AA1, ARG, Intermittency_Factor;
		if (Input_Flag.Is_Cone == 0)
		{
			AA1 = 60 + 4.86 * pow(Edge.Mach, 1.92);
			ARG = (3 / (AA1 * AA1)) * pow((Edge.Rey_No - Re_transition), 2) * pow(Re_transition, -1.34);

		}
		else
		{
			AA1 = 60 + 4.86 * pow(Edge.Mach, 1.92);
			ARG = (3 / (AA1 * AA1)) * (Edge.Rey_No - Re_transition) * pow(Re_transition, -0.34) * (log(Edge.Rey_No / Re_transition));
		}

		if (ARG < -10)
		{
			Intermittency_Factor = 1;
		}
		else
		{
			Intermittency_Factor = 1 - exp(-ARG);
		}
		HF_Convective.Cf_net = HF_Convective.Cf_laminar + (Intermittency_Factor) * (HF_Convective.Cf_turbulent - HF_Convective.Cf_laminar);
		HF_Convective.Ch = HF_Convective.Cf_net / (2 * HF_Convective.RAF_turbulent);
		Hrecovery = Edge.Enthalpy + 0.5 * Edge.Velocity * Edge.Velocity * HF_Convective.rec_turbulent;
		HF_Convective.q_turbulent = HF_Convective.Ch * Edge.Density * Edge.Velocity * (Hrecovery - wall.Enthalpy);
		Shear = 0.5 * Edge.Density * Edge.Velocity * Edge.Velocity * HF_Convective.Cf_net;
		HF_Convective.q_Flat_Plate = HF_Convective.q_turbulent ;

	}

	else if (Input_Flag.Eckert == 1  && Input_Flag.Full_turbulent == 0)
	{

		HF_Convective.rec_laminar = sqrt(Edge.Pr);
		Properties RECOVERY;
		Properties STAR;
		double TREC, TREC1, HREC, HR, DELTA_TEMP, ITER_1, CONVERGENCE_CRITERIA, Hrecovery;
		TREC = Edge.Temperature * (1 + (Edge.Gamma - 1) * 0.5 * HF_Convective.rec_laminar * Edge.Mach * Edge.Mach);
		TREC1 = TREC;
		HREC = Edge.Enthalpy + 0.5 * Edge.Velocity * Edge.Velocity * HF_Convective.rec_laminar;
		ITER_1 = 0;
		CONVERGENCE_CRITERIA = 1;
		while (CONVERGENCE_CRITERIA > 0.00001 && ITER_1 < 41)
		{
			TREC = 0.5 * (TREC + TREC1);
			RECOVERY.Pressure = Edge.Pressure;
			RECOVERY.Temperature = TREC;
			Hansen(RECOVERY);
			TREC1 = TREC;
			DELTA_TEMP = (HREC - RECOVERY.Enthalpy) / (RECOVERY.Cp + (0.5 * Edge.Mach * Edge.Mach * Edge.Gamma * Edge.Z * 287));
			CONVERGENCE_CRITERIA = abs(DELTA_TEMP / TREC);
			if(CONVERGENCE_CRITERIA>0.00001)
            {
                TREC = TREC + DELTA_TEMP;
            }
			else{
                break;
			}
			ITER_1 = ITER_1 + 1;


		}
		double TSTAR, HSTAR, DELTA_TEMP_STAR, CONVERGENCE_CRITERIA2, ITER_2, TSTAR1;
		ITER_2 = 0;
		CONVERGENCE_CRITERIA2 = 1;
		TSTAR = 0.5 * (wall.Temperature + Edge.Temperature) + 0.22 * (TREC - Edge.Temperature);
        HSTAR = 0.5 * (wall.Enthalpy + Edge.Enthalpy) + 0.22 * (HREC - Edge.Enthalpy);
		while (CONVERGENCE_CRITERIA2 > 0.0001 && ITER_2 < 31)
		{

			STAR.Temperature = TSTAR;
			STAR.Pressure = Edge.Pressure;
			Hansen(STAR);
			DELTA_TEMP_STAR = (HSTAR - STAR.Enthalpy) / (Edge.Cp + (0.5 * Edge.Mach * Edge.Mach * Edge.Gamma * Edge.Z * 287));
			TSTAR1 = TSTAR;
			TSTAR = TSTAR + DELTA_TEMP_STAR;
			TSTAR = 0.5 * (TSTAR + TSTAR1);
			CONVERGENCE_CRITERIA2 = abs(DELTA_TEMP_STAR / TSTAR);
			ITER_2 = ITER_2 + 1;


		}

		HF_Convective.RAF_laminar = pow(STAR.Pr, 0.666666666666667);
		STAR.Rey_No = (Edge.Velocity * Running_length * STAR.Density) / STAR.Viscosity;
		STAR.Rey_No = STAR.Rey_No / (2 * Input_Flag.Is_Cone + 1);
		STAR.Rey_No = STAR.Rey_No / 2;
		HF_Convective.Cf_laminar = 0.664 / (sqrt(STAR.Rey_No));
		HF_Convective.Ch_laminar = HF_Convective.Cf_laminar / (2 * HF_Convective.RAF_laminar);
		Hrecovery = Edge.Enthalpy + 0.5 * Edge.Velocity * Edge.Velocity * HF_Convective.rec_laminar;
		HF_Convective.q_laminar = HF_Convective.Ch_laminar * STAR.Density * Edge.Velocity * (Hrecovery - wall.Enthalpy);
		Shear = 0.5 * Edge.Density * Edge.Velocity * Edge.Velocity * HF_Convective.Cf_laminar;
		HF_Convective.q_Flat_Plate = HF_Convective.q_laminar ;
	}

	else if (Input_Flag.Eckert == 1 && Input_Flag.Full_turbulent == 1)
	{
		HF_Convective.rec_turbulent = pow(Edge.Pr, 0.3333333333333333);
		Properties RECOVERY;
		Properties STAR;
		double TREC, TREC1, HREC, HR, DELTA_TEMP, ITER_1, CONVERGENCE_CRITERIA, Hrecovery;
		TREC = Edge.Temperature * (1 + (Edge.Gamma - 1) * 0.5 * HF_Convective.rec_turbulent * Edge.Mach * Edge.Mach);
		TREC1 = TREC;
		HREC = Edge.Enthalpy + 0.5 * Edge.Velocity * Edge.Velocity * HF_Convective.rec_turbulent;
		ITER_1 = 0;
		CONVERGENCE_CRITERIA = 1;
		while (CONVERGENCE_CRITERIA > 0.00001 && ITER_1 < 41)
		{
			TREC = 0.5 * (TREC + TREC1);
			RECOVERY.Pressure = Edge.Pressure;
			RECOVERY.Temperature = TREC;
			Hansen(RECOVERY);
			TREC1 = TREC;
			// DELTA_TEMP=(HREC-RECOVERY.Enthalpy)/(RECOVERY.Cp+(0.5*Edge.Mach*Edge.Mach*Edge.Gamma*Edge.Z*287));
			DELTA_TEMP = (HREC - RECOVERY.Enthalpy) / (RECOVERY.Cp);
			TREC = TREC + DELTA_TEMP;
			ITER_1 = ITER_1 + 1;
			CONVERGENCE_CRITERIA = abs(DELTA_TEMP / TREC);
		}
		double TSTAR, HSTAR, DELTA_TEMP_STAR, CONVERGENCE_CRITERIA2, ITER_2, TSTAR1;
		ITER_2 = 0;
		CONVERGENCE_CRITERIA2 = 1;
		TSTAR = 0.5 * (wall.Temperature + Edge.Temperature) + 0.22 * (TREC - Edge.Temperature);
        HSTAR = 0.5 * (wall.Enthalpy + Edge.Enthalpy) + 0.22 * (HREC - Edge.Enthalpy);
		while (CONVERGENCE_CRITERIA2 > 0.0001 && ITER_2 < 31)
		{

			STAR.Temperature = TSTAR;
			STAR.Pressure = Edge.Pressure;
			Hansen(STAR);
			DELTA_TEMP_STAR = (HSTAR - STAR.Enthalpy) / (Edge.Cp + (0.5 * Edge.Mach * Edge.Mach * Edge.Gamma * Edge.Z * 287));
			TSTAR1 = TSTAR;
			TSTAR = TSTAR + DELTA_TEMP_STAR;
			TSTAR = 0.5 * (TSTAR + TSTAR1);
			CONVERGENCE_CRITERIA2 = abs(DELTA_TEMP_STAR / TSTAR);
			ITER_2 = ITER_2 + 1;
		}

		HF_Convective.RAF_turbulent = pow(STAR.Pr, 0.66666666666667);
		STAR.Rey_No = (Edge.Velocity * Running_length * STAR.Density) / STAR.Viscosity;
		STAR.Rey_No = STAR.Rey_No / (1 * Input_Flag.Is_Cone + 1);
		HF_Convective.Cf_turbulent = 0.37 / (pow(log10(STAR.Rey_No), 2.584));
		HF_Convective.Ch_turbulent = HF_Convective.Cf_turbulent / (2 * HF_Convective.RAF_turbulent);
		Hrecovery = Edge.Enthalpy + 0.5 * Edge.Velocity * Edge.Velocity * HF_Convective.rec_turbulent;
		HF_Convective.q_turbulent = HF_Convective.Ch_turbulent * STAR.Density * Edge.Velocity * (Hrecovery - wall.Enthalpy);
		Shear = 0.5 * Edge.Density * Edge.Velocity * Edge.Velocity * HF_Convective.Cf_turbulent;
		HF_Convective.q_Flat_Plate = HF_Convective.q_turbulent ;

	}


	Transition_Re(Transition_based_on_Retheta,Re_transition_criteria, Rey_No_Edge1, Re_transition, Edge, HF_Convective);


	if (Input_Flag.Eckert == 1 && Input_Flag.Full_turbulent == 0 && Rey_No_Edge1 >= Re_transition_criteria)
	{
		HF_Convective.rec_laminar = sqrt(Edge.Pr);
		Properties RECOVERY;
		Properties STAR;
		double TREC, TREC1, HREC, HR, DELTA_TEMP, ITER_1, CONVERGENCE_CRITERIA, Hrecovery;
		TREC = Edge.Temperature * (1 + (Edge.Gamma - 1) * 0.5 * HF_Convective.rec_laminar * Edge.Mach * Edge.Mach);
		TREC1 = TREC;
		HREC = Edge.Enthalpy + 0.5 * Edge.Velocity * Edge.Velocity * HF_Convective.rec_laminar;
		ITER_1 = 0;
		CONVERGENCE_CRITERIA = 1;
		while (CONVERGENCE_CRITERIA > 0.00001 && ITER_1 < 41)
		{
			TREC = 0.5 * (TREC + TREC1);

			RECOVERY.Pressure = Edge.Pressure;
			RECOVERY.Temperature = TREC;
			Hansen(RECOVERY);
			TREC1 = TREC;
			DELTA_TEMP = (HREC - RECOVERY.Enthalpy) / (RECOVERY.Cp + (0.5 * Edge.Mach * Edge.Mach * Edge.Gamma * Edge.Z * 287));
			TREC = TREC + DELTA_TEMP;
			ITER_1 = ITER_1 + 1;
			CONVERGENCE_CRITERIA = abs(DELTA_TEMP / TREC);
		}
		double TSTAR, HSTAR, DELTA_TEMP_STAR, CONVERGENCE_CRITERIA2, ITER_2, TSTAR1;
		ITER_2 = 0;
		CONVERGENCE_CRITERIA2 = 1;
		TSTAR = 0.5 * (wall.Temperature + Edge.Temperature) + 0.22 * (TREC - Edge.Temperature);
        HSTAR = 0.5 * (wall.Enthalpy + Edge.Enthalpy) + 0.22 * (HREC - Edge.Enthalpy);
		while (CONVERGENCE_CRITERIA2 > 0.0001 && ITER_2 < 31)
		{

			STAR.Temperature = TSTAR;
			STAR.Pressure = Edge.Pressure;
			Hansen(STAR);
			DELTA_TEMP_STAR = (HSTAR - STAR.Enthalpy) / (Edge.Cp + (0.5 * Edge.Mach * Edge.Mach * Edge.Gamma * Edge.Z * 287));
			TSTAR1 = TSTAR;
			TSTAR = TSTAR + DELTA_TEMP_STAR;
			TSTAR = 0.5 * (TSTAR + TSTAR1);
			CONVERGENCE_CRITERIA2 = abs(DELTA_TEMP_STAR / TSTAR);
			ITER_2 = ITER_2 + 1;
		}

		HF_Convective.RAF_laminar = pow(STAR.Pr, 0.666666666666667);
		STAR.Rey_No = (Edge.Velocity * Running_length * STAR.Density) / STAR.Viscosity;
		STAR.Rey_No = (STAR.Rey_No-RETS) / (2 * Input_Flag.Is_Cone + 1);
		STAR.Rey_No = (STAR.Rey_No-RETS) /2;
		HF_Convective.Cf_laminar = 0.664 / (sqrt(STAR.Rey_No));


		HF_Convective.rec_turbulent = pow(Edge.Pr, 0.3333333333333333);
		TREC = Edge.Temperature * (1 + (Edge.Gamma - 1) * 0.5 * HF_Convective.rec_turbulent * Edge.Mach * Edge.Mach);
		TREC1 = TREC;
		HREC = Edge.Enthalpy + 0.5 * Edge.Velocity * Edge.Velocity * HF_Convective.rec_turbulent;
		ITER_1 = 0;
		CONVERGENCE_CRITERIA = 1;
		while (CONVERGENCE_CRITERIA > 0.00001 && ITER_1 < 41)
		{
			TREC = 0.5 * (TREC + TREC1);
			RECOVERY.Pressure = Edge.Pressure;
			RECOVERY.Temperature = TREC;
			Hansen(RECOVERY);
			TREC1 = TREC;
			// DELTA_TEMP=(HREC-RECOVERY.Enthalpy)/(RECOVERY.Cp+(0.5*Edge.Mach*Edge.Mach*Edge.Gamma*Edge.Z*287));
			DELTA_TEMP = (HREC - RECOVERY.Enthalpy) / (RECOVERY.Cp);
			TREC = TREC + DELTA_TEMP;
			ITER_1 = ITER_1 + 1;
			CONVERGENCE_CRITERIA = abs(DELTA_TEMP / TREC);
		}

		ITER_2 = 0;
		CONVERGENCE_CRITERIA2 = 1;
        TSTAR = 0.5 * (wall.Temperature + Edge.Temperature) + 0.22 * (TREC - Edge.Temperature);
        HSTAR = 0.5 * (wall.Enthalpy + Edge.Enthalpy) + 0.22 * (HREC - Edge.Enthalpy);
		while (CONVERGENCE_CRITERIA2 > 0.0001 && ITER_2 < 31)
		{

			STAR.Temperature = TSTAR;
			STAR.Pressure = Edge.Pressure;
			Hansen(STAR);
			DELTA_TEMP_STAR = (HSTAR - STAR.Enthalpy) / (Edge.Cp + (0.5 * Edge.Mach * Edge.Mach * Edge.Gamma * Edge.Z * 287));
			TSTAR1 = TSTAR;
			TSTAR = TSTAR + DELTA_TEMP_STAR;
			TSTAR = 0.5 * (TSTAR + TSTAR1);
			CONVERGENCE_CRITERIA2 = abs(DELTA_TEMP_STAR / TSTAR);
			ITER_2 = ITER_2 + 1;
		}

		HF_Convective.RAF_turbulent = pow(STAR.Pr,0.66666666666667);

		STAR.Rey_No = (Edge.Velocity * Running_length * STAR.Density) / STAR.Viscosity;
		STAR.Rey_No = (STAR.Rey_No-RETS) / (1 * Input_Flag.Is_Cone + 1);
		HF_Convective.Cf_turbulent = 0.37 / (pow(log10(STAR.Rey_No), 2.584));


            if(Transition_based_on_Retheta==1)
            {
                Re_transition = (0.664)/((2*Re_transition*Edge.Viscosity)/(Edge.Density*Edge.Velocity));
            }



		double AA1, ARG, Intermittency_Factor;
		if (Input_Flag.Is_Cone == 0)
		{
			AA1 = 60 + 4.86 * pow(Edge.Mach, 1.92);
			ARG = (3 / (AA1 * AA1)) * pow((Edge.Rey_No - Re_transition), 2) * pow(Re_transition, -1.34);

		}
		else
		{
			AA1 = 60 + 4.86 * pow(Edge.Mach, 1.92);
			ARG = (3 / (AA1 * AA1)) * (Edge.Rey_No - Re_transition) * pow(Re_transition, -0.34) * (log(Edge.Rey_No / Re_transition));
		}

		if (ARG < -10)
		{
			Intermittency_Factor = 1;
		}
		else
		{
			Intermittency_Factor = 1 - exp(-ARG);
		}
		HF_Convective.Cf_net = HF_Convective.Cf_laminar + (Intermittency_Factor) * (HF_Convective.Cf_turbulent - HF_Convective.Cf_laminar);
		HF_Convective.Ch = HF_Convective.Cf_net / (2 * HF_Convective.RAF_turbulent);
		Hrecovery = Edge.Enthalpy + 0.5 * Edge.Velocity * Edge.Velocity * HF_Convective.rec_turbulent;
		HF_Convective.q_turbulent = HF_Convective.Ch * STAR.Density * Edge.Velocity * (Hrecovery - wall.Enthalpy);
		Shear = 0.5 * Edge.Density * Edge.Velocity * Edge.Velocity * HF_Convective.Cf_net;
        HF_Convective.q_Flat_Plate = HF_Convective.q_turbulent ;


	}

	// COMPUTING RECOVERY TEMPERATURE
    Temperature_Recovery = Downstream_Total.Temperature;
    int ITER_TRECOVERY=0;
    double DELT_RECOVERY;
    Properties FINDING_TRECOVERY;
    FINDING_TRECOVERY.Pressure = Edge.Pressure;
    FINDING_TRECOVERY.Temperature=Temperature_Recovery ;
    while(ITER_TRECOVERY<=10 &&     abs(DELT_RECOVERY/Temperature_Recovery)<0.01)
    {
       Hansen(FINDING_TRECOVERY);
       DELT_RECOVERY = (Hrecovery-FINDING_TRECOVERY.Enthalpy)/FINDING_TRECOVERY.Cp;
       Temperature_Recovery=Temperature_Recovery+DELT_RECOVERY;
       FINDING_TRECOVERY.Temperature = Temperature_Recovery;
       ITER_TRECOVERY = ITER_TRECOVERY +1;
    }



}

// Lees Heating (Sphere & Blunt cone), based on Fay & Ridell heating only
void Lees_Heating(Properties& Freestream, struct Heat_Flux_Convective& HF_Convective, struct Geometry& Component1, double  Analysis_Location, double Running_length)
{
	double D_theta, Ratio_spherical_lees;
	double Angle_Axis = Running_length/Component1.Radius;
	D_theta = (1 - (1 / (Freestream.Gamma * Freestream.Mach * Freestream.Mach))) * (pow(Angle_Axis, 2) - ((Angle_Axis * sin(4 * Angle_Axis)) / 2) + ((1 - cos(4 * Angle_Axis)) / 8)) + (4 / (Freestream.Gamma * Freestream.Mach * Freestream.Mach)) * (pow(Angle_Axis, 2) - ((Angle_Axis * sin(2 * Angle_Axis))) + ((1 - cos(2 * Angle_Axis)) / 2));
	Ratio_spherical_lees = (2 * Angle_Axis * sin(Angle_Axis) * (pow(cos(Angle_Axis), 2) + (pow(sin(Angle_Axis), 2)) * (1 / (Freestream.Gamma * Freestream.Mach * Freestream.Mach)))) / sqrt(D_theta);
	HF_Convective.q_Lees_spherical = HF_Convective.q_Stagnation * Ratio_spherical_lees;


	double s_dash_by_Ro, D_Thetac, A_Thetac, B_Thetac, Ratio_conical_lees;
	s_dash_by_Ro = (cos(Component1.Theta) / sin(Component1.Theta)) + ((Running_length / Component1.Radius) - (M_PI / 2 - Component1.Theta));

	D_Thetac = (1 - (1 / (Freestream.Gamma * Freestream.Mach * Freestream.Mach))) * (pow(M_PI / 2 - Component1.Theta, 2) - (((M_PI / 2 - Component1.Theta) * sin(4 * (M_PI / 2 - Component1.Theta))) / 2) + ((1 - cos(4 * (M_PI / 2 - Component1.Theta))) / 8)) + (4 / (Freestream.Gamma * Freestream.Mach * Freestream.Mach)) * (pow((M_PI / 2 - Component1.Theta), 2) - (((M_PI / 2 - Component1.Theta) * sin(2 * (M_PI / 2 - Component1.Theta)))) + ((1 - cos(2 * (M_PI / 2 - Component1.Theta))) / 2));

	A_Thetac = ((sqrt(3) / 2) * sqrt((1 - (1 / (Freestream.Gamma * Freestream.Mach * Freestream.Mach))) * pow(sin(Component1.Theta), 2) + (1 / (Freestream.Gamma * Freestream.Mach * Freestream.Mach)))) * sqrt(M_PI - Component1.Theta);
	B_Thetac = (3 / 16) / (pow(sin(Component1.Theta), 4) + (pow(sin(2*Component1.Theta), 2) / 4) / ((1 / (Freestream.Gamma * Freestream.Mach * Freestream.Mach)))) * (D_Thetac / (M_PI / 2 - Component1.Theta)) - (pow(cos(Component1.Theta) / sin(Component1.Theta), 3));

	Ratio_conical_lees = (A_Thetac * (s_dash_by_Ro)) / (sqrt(B_Thetac + pow(s_dash_by_Ro, 3)));
	HF_Convective.q_Lees_Conical = HF_Convective.q_Stagnation * Ratio_spherical_lees;

}



//Free Molecular heating
void Free_Molecular_Heating(Properties& Freestream, struct Heat_Flux_Convective& HF_Convective, Properties& wall, double &p)
{
	double Molecular_Speed_ratio, Flow_angle_of_incidence;
	Molecular_Speed_ratio = Freestream.Velocity / sqrt(2 * 287 * Freestream.Temperature);
	Flow_angle_of_incidence = M_PI / 2;
	//HF_Convective.q_FreeMolecular = 0.9 * Freestream.Density * 287 * Freestream.Temperature * sqrt((287 * Freestream.Temperature) / (2 * M_PI)) * ((pow(Molecular_Speed_ratio, 2) + (Freestream.Gamma / (Freestream.Gamma - 1)) - ((Freestream.Gamma + 1) / (2 * (Freestream.Gamma - 1))) * (wall.Temperature / Freestream.Temperature)) * (exp(-pow(Molecular_Speed_ratio * sin(Flow_angle_of_incidence), 2)) + sqrt(M_PI) * Molecular_Speed_ratio * sin(Flow_angle_of_incidence) * (1 + erf(Molecular_Speed_ratio * sin(Flow_angle_of_incidence)))) - 0.5 * exp(-pow(Molecular_Speed_ratio * sin(Flow_angle_of_incidence), 2)));


	double FF1,FF2,FF3,FF4;
	FF1 = 0.9 * Freestream.Density * 287 * Freestream.Temperature * sqrt((287 * Freestream.Temperature) / (2 * M_PI)) ;
	FF2= pow(Molecular_Speed_ratio, 2) + (Freestream.Gamma / (Freestream.Gamma - 1)) - ((Freestream.Gamma + 1) / (2 * (Freestream.Gamma - 1))) * (wall.Temperature / Freestream.Temperature);
	FF3= exp(-pow(Molecular_Speed_ratio * sin(Flow_angle_of_incidence), 2)) + sqrt(M_PI) * Molecular_Speed_ratio * sin(Flow_angle_of_incidence)*(1+erf(Molecular_Speed_ratio * sin(Flow_angle_of_incidence)));
	FF4= 0.5 * exp(-pow(Molecular_Speed_ratio * sin(Flow_angle_of_incidence), 2));
	HF_Convective.q_FreeMolecular=FF1*(FF2*FF3-FF4);

	p = 1 - exp(-Freestream.Knudsen_number);

   //cout <<  HF_Convective.q_FreeMolecular << endl;
}
















// Get h_convection & h_radiation incase of air gap
void Air_Gap(double& h_convection, double& h_radiation, double AIR_GAP,double LENGTH, double Temp_1,double Temp_2,double Sea_Level_pressure,double Emmisivity_1,double Emmisivity_2,struct Input_Flag Input_Flag)
{
    double Sigma;
    Sigma=5.67*pow(10,-8);
    int FACTOR;
    double Tbar,beta,Diffusivity,Dynamic_Viscosity,Acceleration_due_to_gravity;
	h_convection = 5;
	h_radiation = 5;

	if(Temp_1==Temp_2)
    {
    h_convection = 0;
	h_radiation = 0;
    }
else
    {
    if(Temp_1>Temp_2)
    {
        FACTOR=1;
    }
    else
    {
        FACTOR=-1;
    }
Tbar= 0.5*(Temp_1+Temp_2);
beta=1/Tbar;
Properties AIR_GAP_PROPERTIES;
AIR_GAP_PROPERTIES.Temperature=Tbar;
AIR_GAP_PROPERTIES.Pressure=Sea_Level_pressure;
Hansen(AIR_GAP_PROPERTIES);
Diffusivity=AIR_GAP_PROPERTIES.Conductivity/(AIR_GAP_PROPERTIES.Density*AIR_GAP_PROPERTIES.Cp);
Dynamic_Viscosity = AIR_GAP_PROPERTIES.Viscosity/AIR_GAP_PROPERTIES.Density;
if(Input_Flag.Coordinate==0)
{
    //Parallel plate
    double AIR_GAP_HALF;
    AIR_GAP_HALF = AIR_GAP/2;


    double Gr_No,Gr_No_s,CL,CL_BAR,A74,C3,C3RA,Nu_1,S,A1,A2,A3,A4,i,DS,AI,Nu_R,h_convection1;
    Gr_No = ((Acceleration_due_to_gravity*beta*(Temp_1-Temp_2)*(pow(AIR_GAP,3)))/(Dynamic_Viscosity*Diffusivity))*FACTOR;

    Gr_No_s = Gr_No*(AIR_GAP/LENGTH);
    CL = 0.48*pow((AIR_GAP_PROPERTIES.Pr/(AIR_GAP_PROPERTIES.Pr+0.861)),0.25);
    CL_BAR=1.3333*CL;
    A74=0.919062526849;
    C3=pow(12*A74*CL_BAR,1.3333);
    C3RA=C3/Gr_No_s;
    Nu_1=CL_BAR*pow(Gr_No_s,0.25);


    S=0;
    A1=-1;
    i=1;
    A4=0;

    if(C3RA<=20)
    {
     while(abs(DS)>0.0001)
    {
      AI=i;
      A1=A1*(-1);
      A2=pow(C3RA,(AI-1));
      A3=3/(4*AI-1);
      A4=A4*(AI-1);
      if(A4==0)
      {
          A4=1;
      }
      DS=(A1*A2*A3)/A4;
      S=S+DS;
      i=i+1;
    }
    Nu_R=Nu_1*S;
    h_convection1=(Nu_R*AIR_GAP_PROPERTIES.Conductivity)/AIR_GAP;

    }


}
else if(Input_Flag.Coordinate==1)
{
    //Coaxial Cylinders

    double Diameter_Outer,Diameter_Inner,Thickness,Gr_No,Gr_No_s,A1,A2,EKEF,Nu_R,h_convection1;
    Diameter_Outer=LENGTH;
    Diameter_Inner=AIR_GAP;
    Thickness = 0.5*(Diameter_Outer-Diameter_Inner);
    Gr_No = ((Acceleration_due_to_gravity*beta*(Temp_1-Temp_2)*(pow(Thickness,3)))/(Dynamic_Viscosity*Diffusivity))*FACTOR;
    A1=log(Diameter_Outer/Diameter_Inner);
    A2=pow(Thickness,3)*pow(((1/pow(Diameter_Outer,0.6))+(1/pow(Diameter_Inner,0.6))),5);
    Gr_No_s=(Gr_No*pow(A1,4))/A2;
    EKEF=0.386*pow((AIR_GAP_PROPERTIES.Pr/(AIR_GAP_PROPERTIES.Pr+0.861)),0.25)*pow(Gr_No_s,0.25);
    if(EKEF=1)
    {
        EKEF=1;
    }

     h_convection1=(2*AIR_GAP_PROPERTIES.Conductivity*EKEF)/(A1*Diameter_Inner);
     Nu_R=(h_convection1*Thickness)/AIR_GAP_PROPERTIES.Conductivity;
}




   }


h_convection=h_convection*FACTOR;


double ELH,F,AR1,AR2,AR3,FAC,QRAD;
ELH=LENGTH/AIR_GAP;
F=sqrt(1+1/(ELH*ELH))-1/ELH;
if(Input_Flag.Coordinate==1)
{
    F=1/ELH;
}
AR1=(1-Emmisivity_1)/Emmisivity_1;
AR2=(1-Emmisivity_2)/Emmisivity_2;
AR3=1/F;
FAC=1/(AR1+AR2+AR3);
QRAD=FAC*Sigma*(pow(Temp_1,4)-pow(Temp_2,4));
h_radiation=QRAD/(Temp_1-Temp_2);

}


// Get attributes of material properties
struct Material_Property
{
	VectorXd Temp_k;
	VectorXd Temp_rho;
	VectorXd Temp_Cp;
	VectorXd Temp_epsilon;
	VectorXd k;
	VectorXd rho;
	VectorXd Cp;
	VectorXd epsilon;
	double T_Ablation;
	double T_Pyrolysis;
	double Heat_Pyrolysis;
	double Heat_Ablation;
	double Density_Virgin;
	double Density_Char;
	double Density_Pyrolysis_gas;
};


//FOR CYLINDRICAL/SPHERICAL COORDINATE TRANSFORMATION (RADIUS != 0)
void CYSP2(double& A1, double& B1, double& C1, double k, double Inverse_ratio, struct Input_Flag Input_Flag)
{
	double Coordinate_ratio;
	Coordinate_ratio = (Input_Flag.Coordinate * k) / pow(Inverse_ratio, 2);
	A1 = A1 + Coordinate_ratio;
	B1 = B1 - 2 * Coordinate_ratio;
	C1 = C1 + Coordinate_ratio;
}

//FOR CYLINDRICAL/SPHERICAL COORDINATE TRANSFORMATION (RADIUS == 0)
void CYSP1(double& A1, double& C1, double k, double Layer_thickness, double Inverse_ratio, double Outer_radius_instantaneous, struct Input_Flag Input_Flag)
{
	double Coordinate_ratio;
	Coordinate_ratio = (Input_Flag.Coordinate * k * Layer_thickness) / (2 * Inverse_ratio * Outer_radius_instantaneous);
	A1 = A1 + Coordinate_ratio;
	C1 = C1 + Coordinate_ratio;
}


//Get Backwall convection & radiation
void FreeConvection_Surface(double T,double T_AMBIENT, double &Free_Convection_h, double Characteristic_Length, double Sea_Level_Pressure,int Use_Correlation_or_value_backwall_convection)
{
  double Tbar,Acceleration_due_to_Gravity;
  Tbar=0.5*(T+T_AMBIENT);
  Acceleration_due_to_Gravity=9.80665;
  Properties INSIDE_BACK_WALL_FLOW;
  INSIDE_BACK_WALL_FLOW.Temperature=Tbar;
  INSIDE_BACK_WALL_FLOW.Pressure=Sea_Level_Pressure;
  Hansen(INSIDE_BACK_WALL_FLOW);

  double delta_Temp;
  delta_Temp=Tbar-T_AMBIENT;
  double Gr_No,Gr_No_Pr,Nu;
  Gr_No=(Acceleration_due_to_Gravity*delta_Temp*pow(Characteristic_Length,3)*pow(INSIDE_BACK_WALL_FLOW.Density,2))/(Tbar*pow(INSIDE_BACK_WALL_FLOW.Viscosity,2));
  Gr_No_Pr=Gr_No*INSIDE_BACK_WALL_FLOW.Pr;

  if(Gr_No_Pr>1000000000)
  {
      Nu=0.13*pow(Gr_No_Pr,0.333);
  }
  else{
      Nu=0.59*pow(Gr_No_Pr,0.25);
  }

  if(Use_Correlation_or_value_backwall_convection==0)
  {
      Free_Convection_h = Nu*(INSIDE_BACK_WALL_FLOW.Conductivity/Characteristic_Length);
  }
  else
  {
       Free_Convection_h = Free_Convection_h;
  }
}

//Get thermal response
void Thermal_Response(int No_of_Layers, VectorXi No_of_nodes, VectorXd Inverse_nodes, VectorXi Material_Index, VectorXd Initial_Layer_thickness, VectorXd& Layer_thickness, double Qradiation, double heat_transfer_coefficient_outer, double Tg, double Tspace, VectorXd k, VectorXd Cp, VectorXd rho, VectorXd epsilon, double Temp_Ablation, double Temp_Pyrolysis, double Heat_of_Pyrolysis, double Heat_of_Ablation, double Density_of_Virgin, double Density_of_Char, double Density_of_Pyrolysis_gas, VectorXd& T, VectorXd& Tinitial, double& delt, double Mass_rate_Char, double Mass_rate_Pyrolysis, struct Input_Flag& Input_Flag, double Propellant_Mass, double X1_Thin, double X2_Thin, double Outer_Radius, double Cp_Pyrolysis_gas, VectorXd SS, double T_Ambient_Convection,double &h_convection_backwall, double Characteristic_Length_backwall_convection, double Sea_Level_Pressure, int Use_Correlation_or_value_backwall_convection, double Q_RADIATION_BACKWALL, double T_Ambient_Radiation,double Back_wall_Convection_ON, double Backwall_wall_Radiation_loss_ON  )
{


	MatrixXd A, B;
	A = MatrixXd::Zero(No_of_nodes.sum() + 1, No_of_nodes.sum() + 1);
	B = MatrixXd::Zero(No_of_nodes.sum() + 1, 1);
	//T = MatrixXd::Zero(No_of_nodes.sum()+1, 1);
	//SS = MatrixXd::Zero(No_of_nodes.sum()+1, 1);
	double MPD, MCD, CPG, Outer_radius_instantaneous;

	if (Input_Flag.Coordinate != 0) {
		Outer_radius_instantaneous = Outer_Radius - Initial_Layer_thickness(0) - Initial_Layer_thickness(1) + Layer_thickness(0) + Layer_thickness(1);
	}

	double AA1_s, AA2_s, BB1_s, BB2_s, CC1_s, CC2_s, DD1_s, DD2_s;
	double sigma;
	sigma = 5.67 * pow(10, -8);
	MPD = Mass_rate_Pyrolysis;
	MCD = Mass_rate_Char;
	CPG = Cp_Pyrolysis_gas;



	if (Layer_thickness(0) != 0)
	{
		if (MCD != 0)
		{
			A(0, 0) = 1;
			A(0, 1) = 0;
			B(0, 0) = Temp_Ablation;
		}

		else if (Mass_rate_Char == 0)
		{
			AA2_s = k(0) / pow(Inverse_nodes(0), 2) - (MPD * CPG * Layer_thickness(0)) / (2 * Inverse_nodes(0));
			BB2_s = -((3 * k(0) + k(1)) / (2 * (pow(Inverse_nodes(0), 2)))) - (((rho(0) * Cp(0)) / delt) * Layer_thickness(0) * Layer_thickness(0));
			CC2_s = ((k(0) + k(1)) / (2 * (pow(Inverse_nodes(0), 2))) + (MPD * CPG * Layer_thickness(0)) / (2 * Inverse_nodes(0)));
			DD2_s = -(((rho(0) * Cp(0)) / delt) * T(0) * Layer_thickness(0) * Layer_thickness(0)) - SS(0) * Layer_thickness(0) * Layer_thickness(0);

			if (Input_Flag.Coordinate != 0)
			{

				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(AA2_s, BB2_s, CC2_s, k(0), Inverse_nodes(0), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(AA2_s, CC2_s, k(0), Layer_thickness(0), Inverse_nodes(0), Outer_radius_instantaneous, Input_Flag);
				}

			}




			AA1_s = k(0) / (2 * Inverse_nodes(0));
			BB1_s = heat_transfer_coefficient_outer * Layer_thickness(0);
			CC1_s = -k(0) / (2 * Inverse_nodes(0));
			DD1_s = (heat_transfer_coefficient_outer * Tg - epsilon(0) * sigma * (pow(T(0), 4)-pow(Tspace,4)) + Qradiation) * Layer_thickness(0);




			A(0, 0) = BB1_s * AA2_s - AA1_s * BB2_s;
			A(0, 1) = AA2_s * CC1_s - AA1_s * CC2_s;
			B(0, 0) = AA2_s * DD1_s - AA1_s * DD2_s;

		}


		//X1THIN OPTION TO ADD

		double Factor1, Factor2;
		for (int i = 1; i < No_of_nodes(0); i++)
		{
			A(i, i - 1) = (k(i - 1) + k(i)) / (2 * (pow(Inverse_nodes(0), 2)));
			A(i, i) = -((k(i - 1) + 2 * k(i) + k(i + 1)) / (2 * (pow(Inverse_nodes(0), 2)))) - ((rho(i) * Cp(i)) / delt) * Layer_thickness(0) * Layer_thickness(0);
			A(i, i + 1) = (k(i) + k(i + 1)) / (2 * (pow(Inverse_nodes(0), 2)));
			Factor1 = (Layer_thickness(0) / Inverse_nodes(0)) * (MPD * CPG + (MCD * rho(i) * Cp(i)) / Density_of_Pyrolysis_gas + ((i) / No_of_nodes(0)) * ((MPD * rho(i) * Cp(i)) / (Density_of_Virgin - Density_of_Char) - (MCD * rho(i) * Cp(i)) / Density_of_Pyrolysis_gas));
			Factor2 = Factor1 / 2;
			if (A(i, i - 1) < Factor2)
			{
				A(i, i) = A(i, i) - Factor1;
				A(i, i + 1) = A(i, i + 1) + Factor1;
			}

			else
			{
				A(i, i - 1) = A(i, i - 1) - Factor2;
				A(i, i + 1) = A(i, i + 1) + Factor2;
			}

			B(i, 0) = -(((rho(i) * Cp(i)) / delt) * T(i) * Layer_thickness(0) * Layer_thickness(0)) - SS(i) * Layer_thickness(0) * Layer_thickness(0);

			if (Input_Flag.Coordinate != 0)
			{
				Outer_radius_instantaneous = Outer_radius_instantaneous - Layer_thickness(0) * Inverse_nodes(0);
				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(A(i, i - 1), A(i, i), A(i, i + 1), k(i), Inverse_nodes(0), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(A(i, i - 1), A(i, i + 1), k(i), Layer_thickness(0), Inverse_nodes(0), Outer_radius_instantaneous, Input_Flag);
				}

			}


		}


		if (Input_Flag.Coordinate != 0)
		{
			Outer_radius_instantaneous = Outer_radius_instantaneous - Layer_thickness(0) * Inverse_nodes(0);
		}

		if(No_of_Layers>=2)
        {
		if (MPD != 0)
		{
			A(No_of_nodes(0), No_of_nodes(0) - 1) = 0;
			A(No_of_nodes(0), No_of_nodes(0)) = 1;
			A(No_of_nodes(0), No_of_nodes(0) + 1) = 0;
			B(No_of_nodes(0), 0) = Temp_Pyrolysis;
		}



		else if (MPD == 0 && Layer_thickness(1) != 0)
		{

			double AA1_i, BB1_i, CC1_i, DD1_i, AA3_i, BB3_i, CC3_i, DD3_i, AA2_i, AA2D_i, CC2_i, CC2D_i, BB2, DD2;
			AA1_i = (k(No_of_nodes(0)) + k(No_of_nodes(1) - 1)) / (2 * pow(Inverse_nodes(0), 2));
			BB1_i = -(k(No_of_nodes(0) - 1) + 3 * k(No_of_nodes(0))) / (2 * pow(Inverse_nodes(0), 2)) - (rho(No_of_nodes(0)) * Cp(No_of_nodes(0)) / delt) * Layer_thickness(0) * Layer_thickness(0);
			CC1_i = k(No_of_nodes(0)) / (1 * pow(Inverse_nodes(0), 2));
			DD1_i = -((rho(No_of_nodes(0)) * Cp(No_of_nodes(0)) / delt) * T(No_of_nodes(0)) * Layer_thickness(0) * Layer_thickness(0)) - SS(No_of_nodes(0)) * Layer_thickness(0) * Layer_thickness(0);

			if (Input_Flag.Coordinate != 0)
			{

				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(AA1_i, BB1_i, CC1_i, k(No_of_nodes(0)), Inverse_nodes(0), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(AA1_i, CC1_i, k(No_of_nodes(0)), Layer_thickness(0), Inverse_nodes(0), Outer_radius_instantaneous, Input_Flag);
				}

			}
			AA3_i = k(No_of_nodes(0) + 1) / (1 * pow(Inverse_nodes(1), 2));
			BB3_i = -(k(No_of_nodes(0) + 2) + 3 * k(No_of_nodes(0) + 1)) / (2 * pow(Inverse_nodes(1), 2)) - (rho(No_of_nodes(0) + 1) * Cp(No_of_nodes(0) + 1) / delt) * Layer_thickness(1) * Layer_thickness(1);
			CC3_i = (k(No_of_nodes(0) + 1) + k(No_of_nodes(0) + 2)) / (2 * pow(Inverse_nodes(1), 2));
			DD3_i = -((rho(No_of_nodes(0) + 1) * Cp(No_of_nodes(0) + 1) / delt) * T(No_of_nodes(0)) * Layer_thickness(1) * Layer_thickness(1)) - SS(No_of_nodes(0)) * Layer_thickness(1) * Layer_thickness(1);

			if (Input_Flag.Coordinate != 0)
			{

				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(AA3_i, BB3_i, CC3_i, k(No_of_nodes(0) + 1), Inverse_nodes(1), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(AA3_i, CC3_i, k(No_of_nodes(0) + 1), Layer_thickness(1), Inverse_nodes(1), Outer_radius_instantaneous, Input_Flag);
				}

			}



			AA2_i = -k(No_of_nodes(0)) / (2 * Inverse_nodes(0) * Layer_thickness(0));
			AA2D_i = k(No_of_nodes(0) + 1) / (2 * Inverse_nodes(1) * Layer_thickness(1));
			CC2_i = -AA2D_i;
			CC2D_i = -AA2_i;
			BB2 = 0;
			DD2 = MPD * Heat_of_Pyrolysis;

			A(No_of_nodes(0), No_of_nodes(0) - 1) = AA1_i * CC2D_i * AA3_i - CC1_i * AA2_i * AA3_i;
			A(No_of_nodes(0), No_of_nodes(0)) = BB3_i * CC1_i * AA2D_i + BB1_i * CC2D_i * AA3_i - BB2 * CC1_i * AA3_i;
			A(No_of_nodes(0), No_of_nodes(0) + 1) = CC1_i * AA2D_i * CC3_i - AA3_i * CC1_i * CC2_i;
			B(No_of_nodes(0), 0) = DD3_i * CC1_i * AA2D_i + AA3_i * CC2D_i * DD1_i - DD2 * CC1_i * AA3_i;

		}
	}
	    if(No_of_Layers>=2)
        {
		 if (MPD == 0 && Layer_thickness(1) == 0 && No_of_Layers < 3)
		{
			double AA2_b, BB2_b, CC2_b, DD2_b, AA1_b, BB1_b, CC1_b, DD1_b;
			AA2_b = (k(No_of_nodes(0)) + k(No_of_nodes(0) - 1)) / (2 * pow(Inverse_nodes(0), 2));
			BB2_b = -(k(No_of_nodes(0) - 1) + 3 * k(No_of_nodes(0))) / (2 * pow(Inverse_nodes(0), 2)) - (rho(No_of_nodes(0)) * Cp(No_of_nodes(0)) / delt) * Layer_thickness(0) * Layer_thickness(0);
			CC2_b = k(No_of_nodes(0)) / (1 * pow(Inverse_nodes(0), 2));
			DD2_b = -(rho(No_of_nodes(0)) * Cp(No_of_nodes(0)) / delt) * T(No_of_nodes(0)) * Layer_thickness(0) * Layer_thickness(0) - SS(No_of_nodes(0)) * Layer_thickness(0) * Layer_thickness(0);


			if (Input_Flag.Coordinate != 0)
			{

				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(AA2_b, BB2_b, CC2_b, k(No_of_nodes(0)), Inverse_nodes(0), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(AA2_b, CC2_b, k(No_of_nodes(0)), Layer_thickness(0), Inverse_nodes(0), Outer_radius_instantaneous, Input_Flag);
				}

			}

			AA1_b = k(No_of_nodes(0)) / (2 * Layer_thickness(0) * Inverse_nodes(0));
			BB1_b = 0;
			CC1_b = -k(No_of_nodes(0)) / (2 * Layer_thickness(0) * Inverse_nodes(0));
			DD1_b = 0;

			A(No_of_nodes(0), No_of_nodes(0) - 1) = CC1_b * AA2_b - CC2_b * AA1_b;
			A(No_of_nodes(0), No_of_nodes(0)) = CC1_b * BB2_b - CC2_b * BB1_b;
			B(No_of_nodes(0), 0) = CC1_b * DD2_b - CC2_b * DD1_b;
		}
        }

        if(No_of_Layers==1)
        {
            			double AA2_b, BB2_b, CC2_b, DD2_b, AA1_b, BB1_b, CC1_b, DD1_b;
			AA2_b = (k(No_of_nodes(0)) + k(No_of_nodes(0) - 1)) / (2 * pow(Inverse_nodes(0), 2));
			BB2_b = -(k(No_of_nodes(0) - 1) + 3 * k(No_of_nodes(0))) / (2 * pow(Inverse_nodes(0), 2)) - (rho(No_of_nodes(0)) * Cp(No_of_nodes(0)) / delt) * Layer_thickness(0) * Layer_thickness(0);
			CC2_b = k(No_of_nodes(0)) / (1 * pow(Inverse_nodes(0), 2));
			DD2_b = -(rho(No_of_nodes(0)) * Cp(No_of_nodes(0)) / delt) * T(No_of_nodes(0)) * Layer_thickness(0) * Layer_thickness(0) - SS(No_of_nodes(0)) * Layer_thickness(0) * Layer_thickness(0);


			if (Input_Flag.Coordinate != 0)
			{

				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(AA2_b, BB2_b, CC2_b, k(No_of_nodes(0)), Inverse_nodes(0), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(AA2_b, CC2_b, k(No_of_nodes(0)), Layer_thickness(0), Inverse_nodes(0), Outer_radius_instantaneous, Input_Flag);
				}

			}



			if(Back_wall_Convection_ON==1)
            {
              FreeConvection_Surface(T(No_of_nodes(0)),T_Ambient_Convection, h_convection_backwall, Characteristic_Length_backwall_convection, Sea_Level_Pressure, Use_Correlation_or_value_backwall_convection);

            }
			else
            {
             h_convection_backwall=0;
            }


            double h_radiation_loss_backwall;

            if(Backwall_wall_Radiation_loss_ON==1)
            {
                h_radiation_loss_backwall = sigma*epsilon(No_of_nodes(0))*(pow(T(No_of_nodes(0)),3) + pow(T(No_of_nodes(0)),2)*T_Ambient_Radiation + T(No_of_nodes(0))*pow(T_Ambient_Radiation,2) + pow(T_Ambient_Radiation,3)  );
            }
            else
            {
                h_radiation_loss_backwall =0;
            }

			AA1_b = k(No_of_nodes(0)) / (2 * Layer_thickness(0) * Inverse_nodes(0));
			BB1_b = h_convection_backwall + h_radiation_loss_backwall + Propellant_Mass/delt;
			CC1_b = -k(No_of_nodes(0)) / (2 * Layer_thickness(0) * Inverse_nodes(0));
			DD1_b = Q_RADIATION_BACKWALL + h_convection_backwall*T_Ambient_Convection + h_radiation_loss_backwall*T_Ambient_Radiation + (Propellant_Mass *T(No_of_nodes(0)))/delt;

			A(No_of_nodes(0), No_of_nodes(0) - 1) = CC1_b * AA2_b - CC2_b * AA1_b;
			A(No_of_nodes(0), No_of_nodes(0)) = CC1_b * BB2_b - CC2_b * BB1_b;
			B(No_of_nodes(0), 0) = CC1_b * DD2_b - CC2_b * DD1_b;

        }

		if(No_of_Layers>=3)
        {

		if (MPD == 0 && Layer_thickness(1) == 0 && No_of_Layers >= 3)
		{
			double AA1_i, BB1_i, CC1_i, DD1_i, AA3_i, BB3_i, CC3_i, DD3_i, AA2_i, AA2D_i, CC2_i, CC2D_i, BB2, DD2;
			AA1_i = (k(No_of_nodes(0)) + k(No_of_nodes(1) - 1)) / (2 * pow(Inverse_nodes(0), 2));
			BB1_i = -(k(No_of_nodes(0) - 1) + 3 * k(No_of_nodes(0))) / (2 * pow(Inverse_nodes(0), 2)) - (rho(No_of_nodes(0)) * Cp(No_of_nodes(0)) / delt) * Layer_thickness(0) * Layer_thickness(0);
			CC1_i = k(No_of_nodes(0)) / (1 * pow(Inverse_nodes(0), 2));
			DD1_i = -((rho(No_of_nodes(0)) * Cp(No_of_nodes(0)) / delt) * T(No_of_nodes(0)) * Layer_thickness(0) * Layer_thickness(0)) - SS(No_of_nodes(0)) * Layer_thickness(0) * Layer_thickness(0);


			if (Input_Flag.Coordinate != 0)
			{

				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(AA1_i, BB1_i, CC1_i, k(No_of_nodes(0)), Inverse_nodes(0), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(AA1_i, CC1_i, k(No_of_nodes(0)), Layer_thickness(0), Inverse_nodes(0), Outer_radius_instantaneous, Input_Flag);
				}

			}

			AA3_i = k(No_of_nodes(0) + No_of_nodes(1) + 2) / (1 * pow(Inverse_nodes(2), 2));
			BB3_i = -(k(No_of_nodes(0) + No_of_nodes(1) + 3) + 3 * k(No_of_nodes(0) + No_of_nodes(1) + 2)) / (2 * pow(Inverse_nodes(2), 2)) - (rho(No_of_nodes(0) + No_of_nodes(1) + 2) * Cp(No_of_nodes(0) + No_of_nodes(1) + 2) / delt) * Layer_thickness(2) * Layer_thickness(2);
			CC3_i = (k(No_of_nodes(0) + No_of_nodes(1) + 2) + k(No_of_nodes(0) + No_of_nodes(1) + 3)) / (2 * pow(Inverse_nodes(2), 2));
			DD3_i = -((rho(No_of_nodes(0) + No_of_nodes(1) + 2) * Cp(No_of_nodes(0) + No_of_nodes(1) + 2)) / delt) * T(No_of_nodes(0) + No_of_nodes(1)) * Layer_thickness(2) * Layer_thickness(2) - SS(No_of_nodes(0) + No_of_nodes(1)) * Layer_thickness(2) * Layer_thickness(2);


			if (Input_Flag.Coordinate != 0)
			{

				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(AA3_i, BB3_i, CC3_i, k(No_of_nodes(0) + No_of_nodes(1) + 2), Inverse_nodes(2), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(AA3_i, CC3_i, k(No_of_nodes(0) + No_of_nodes(1) + 2), Layer_thickness(2), Inverse_nodes(2), Outer_radius_instantaneous, Input_Flag);
				}

			}

//
//
			AA2_i = -k(No_of_nodes(0)) / (2 * Inverse_nodes(0) * Layer_thickness(0));
			AA2D_i = k(No_of_nodes(0) + No_of_nodes(1) + 2) / (2 * Inverse_nodes(2) * Layer_thickness(2));
			CC2_i = -AA2D_i;
			CC2D_i = -AA2_i;
			BB2 = 0;
			DD2 = 0;

			A(No_of_nodes(0), No_of_nodes(0) - 1) = AA1_i * CC2D_i * AA3_i - CC1_i * AA2_i * AA3_i;
			A(No_of_nodes(0), No_of_nodes(0)) = BB3_i * CC1_i * AA2D_i + BB1_i * CC2D_i * AA3_i - BB2 * CC1_i * AA3_i;
			A(No_of_nodes(0), No_of_nodes(0) + 1) = CC1_i * AA2D_i * CC3_i - AA3_i * CC1_i * CC2_i;
			B(No_of_nodes(0), 0) = DD3_i * CC1_i * AA2D_i + AA3_i * CC2D_i * DD1_i - DD2 * CC1_i * AA3_i;

			for (int io = No_of_nodes(0) + 1; io < No_of_nodes(0) + No_of_nodes(1) + 1; io++)
			{
				A(io, io - 1) = 1;
				A(io, io) = -1;
				A(io, io + 1) = 0;
				B(io, 0) = 0;
			}
		}

		}
	}


	if(No_of_Layers>=2)
    {

	if (Layer_thickness(1) != 0)
	{
		if (MPD != 0)
		{
			A(No_of_nodes(0), No_of_nodes(0) - 1) = 0;
			A(No_of_nodes(0), No_of_nodes(0)) = 1;
			A(No_of_nodes(0), No_of_nodes(0) + 1) = 0;
			B(No_of_nodes(0), 0) = Temp_Pyrolysis;
		}
		else if (MPD == 0 && Layer_thickness(0) == 0)
		{
			AA2_s = k(No_of_nodes(0) + 1) / (pow(Inverse_nodes(1), 2));
			BB2_s = -(3 * k(No_of_nodes(0) + 1) + k(No_of_nodes(0) + 2)) / (2 * pow(Inverse_nodes(1), 2)) - ((rho(No_of_nodes(0) + 1) * Cp(No_of_nodes(0) + 1)) / delt) * Layer_thickness(1) * Layer_thickness(1);
			CC2_s = (k(No_of_nodes(0) + 1) + k(No_of_nodes(0) + 2)) / (2 * pow(Inverse_nodes(1), 2));
			DD2_s = -((rho(No_of_nodes(0) + 1) * Cp(No_of_nodes(0) + 1)) / delt) * T(No_of_nodes(0)) * Layer_thickness(1) * Layer_thickness(1) - SS(No_of_nodes(0)) * Layer_thickness(1) * Layer_thickness(1);



			if (Input_Flag.Coordinate != 0)
			{

				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(AA2_s, BB2_s, CC2_s, k(No_of_nodes(0) + 1), Inverse_nodes(1), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(AA2_s, CC2_s, k(No_of_nodes(0) + 1), Layer_thickness(1), Inverse_nodes(1), Outer_radius_instantaneous, Input_Flag);
				}

			}




			AA1_s = k(No_of_nodes(0) + 1) / (2 * Inverse_nodes(1) * Layer_thickness(1));
			//BB1_s = heat_transfer_coefficient_outer * Layer_thickness(1);
			BB1_s = heat_transfer_coefficient_outer ;
			CC1_s = -k(No_of_nodes(0) + 2) / (2 * Inverse_nodes(1) * Layer_thickness(1));
			//DD1_s = (heat_transfer_coefficient_outer * Tg - epsilon(No_of_nodes(0) + 1) * sigma * pow(T(No_of_nodes(0)), 4) + Qradiation) * Layer_thickness(1);
             DD1_s = (heat_transfer_coefficient_outer * Tg - epsilon(No_of_nodes(0) + 1) * sigma * pow(T(No_of_nodes(0)), 4) + Qradiation) ;

			A(No_of_nodes(0), No_of_nodes(0) - 1) = 0;
			A(No_of_nodes(0), No_of_nodes(0)) = BB1_s * AA2_s - AA1_s * BB2_s;
			A(No_of_nodes(0), No_of_nodes(0) + 1) = AA2_s * CC1_s - AA1_s * CC2_s;
			B(No_of_nodes(0), 0) = AA2_s * DD1_s - AA1_s * DD2_s;




		}


		for (int jojo = No_of_nodes(0) + 1; jojo < No_of_nodes(0) + No_of_nodes(1); jojo++)
		{
			double Factor_1, Factor_2;
			A(jojo, jojo - 1) = (k(jojo) + k(jojo + 1)) / (2 * pow(Inverse_nodes(1), 2));
			A(jojo, jojo) = -(k(jojo + 2) + 2 * k(jojo + 1) + k(jojo)) / (2 * pow(Inverse_nodes(1), 2)) - ((rho(jojo + 1) * Cp(jojo + 1)) / delt) * Layer_thickness(1) * Layer_thickness(1);
			A(jojo, jojo + 1) = (k(jojo + 1) + k(jojo + 2)) / (2 * pow(Inverse_nodes(1), 2));
			Factor_1 = ((Layer_thickness(1)) * (MPD * (No_of_nodes(0) + No_of_nodes(1) + 1 - jojo) * rho(jojo + 1) * Cp(jojo + 1))) / (Density_of_Virgin - Density_of_Char);
			Factor_2 = Factor_1 / 2;
			if (A(jojo, jojo - 1) < Factor_2)
			{
				A(jojo, jojo) = A(jojo, jojo) - Factor_1;
				A(jojo, jojo + 1) = A(jojo, jojo + 1) + Factor_1;

			}

			else
			{
				A(jojo, jojo - 1) = A(jojo, jojo - 1) - Factor_2;
				A(jojo, jojo + 1) = A(jojo, jojo + 1) + Factor_2;

			}

			B(jojo, 0) = -((rho(jojo + 1) * Cp(jojo + 1)) / delt) * T(jojo) * Layer_thickness(1) * Layer_thickness(1) - SS(jojo) * Layer_thickness(1) * Layer_thickness(1);



			if (Input_Flag.Coordinate != 0)
			{
				Outer_radius_instantaneous = Outer_radius_instantaneous - Layer_thickness(1) * Inverse_nodes(1);
				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(A(jojo, jojo - 1), A(jojo, jojo), A(jojo, jojo + 1), k(jojo + 1), Inverse_nodes(1), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(A(jojo, jojo - 1), A(jojo, jojo + 1), k(jojo + 1), Layer_thickness(1), Inverse_nodes(1), Outer_radius_instantaneous, Input_Flag);
				}

			}


	}

//
		Outer_radius_instantaneous = Outer_radius_instantaneous - Layer_thickness(1) * Inverse_nodes(1);

		if (No_of_Layers < 3)
		{
			double AA2_b, BB2_b, CC2_b, DD2_b, AA1_b, BB1_b, CC1_b, DD1_b;
			AA2_b = (k(No_of_nodes(0) + No_of_nodes(1)) + k(No_of_nodes(0) + No_of_nodes(1) + 1)) / (2 * pow(Inverse_nodes(1), 2));
			BB2_b = -(k(No_of_nodes(0) + No_of_nodes(1)) + 3 * k(No_of_nodes(0) + No_of_nodes(1) + 1)) / (2 * pow(Inverse_nodes(1), 2)) - (rho(No_of_nodes(0) + No_of_nodes(1) + 1) * Cp(No_of_nodes(0) + No_of_nodes(1) + 1) / delt) * Layer_thickness(1) * Layer_thickness(1);
			CC2_b = k(No_of_nodes(0) + No_of_nodes(1) + 1) / (1 * pow(Inverse_nodes(1), 2));
			DD2_b = -(rho(No_of_nodes(0) + No_of_nodes(1) + 1) * Cp(No_of_nodes(0) + No_of_nodes(1) + 1) / delt) * T(No_of_nodes(0) + No_of_nodes(1)) * Layer_thickness(1) * Layer_thickness(1) - SS(No_of_nodes(0) + No_of_nodes(1)) * Layer_thickness(1) * Layer_thickness(1);


			if (Input_Flag.Coordinate != 0)
			{

				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(AA2_b, BB2_b, CC2_b, k(No_of_nodes(0) + No_of_nodes(1) + 1), Inverse_nodes(1), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(AA2_b, CC2_b, k(No_of_nodes(0) + No_of_nodes(1) + 1), Layer_thickness(1), Inverse_nodes(1), Outer_radius_instantaneous, Input_Flag);
				}

			}

            if(Back_wall_Convection_ON ==1)
            {
            FreeConvection_Surface(T(No_of_nodes(0) + No_of_nodes(1)),T_Ambient_Convection, h_convection_backwall, Characteristic_Length_backwall_convection, Sea_Level_Pressure, Use_Correlation_or_value_backwall_convection);
            }
            else
            {
             h_convection_backwall=0;
            }


            double h_radiation_loss_backwall;



            if(Backwall_wall_Radiation_loss_ON==1)
            {
            h_radiation_loss_backwall = sigma*epsilon(No_of_nodes.sum())*(pow(T(No_of_nodes(0) + No_of_nodes(1)),3) + pow(T(No_of_nodes(0) + No_of_nodes(1)),2)*T_Ambient_Radiation + T(No_of_nodes(0) + No_of_nodes(1))*pow(T_Ambient_Radiation,2) + pow(T_Ambient_Radiation,3)  );
            }
            else
            {
            h_radiation_loss_backwall =0;
            }

			AA1_b = k(No_of_nodes(0) + No_of_nodes(1) + 1) / (2 * Layer_thickness(1) * Inverse_nodes(1));
			BB1_b = h_convection_backwall + h_radiation_loss_backwall + Propellant_Mass/delt;
			CC1_b = -k(No_of_nodes(0) + No_of_nodes(1) + 1) / (2 * Layer_thickness(1) * Inverse_nodes(1));
			DD1_b = Q_RADIATION_BACKWALL + h_convection_backwall*T_Ambient_Convection + h_radiation_loss_backwall*T_Ambient_Radiation + (Propellant_Mass *T(No_of_nodes(0) + No_of_nodes(1)))/delt;

			A(No_of_nodes(0) + No_of_nodes(1), No_of_nodes(0) + No_of_nodes(1) - 1) = CC1_b * AA2_b - CC2_b * AA1_b;
			A(No_of_nodes(0) + No_of_nodes(1), No_of_nodes(0) + No_of_nodes(1)) = CC1_b * BB2_b - CC2_b * BB1_b;
			B(No_of_nodes(0) + No_of_nodes(1), 0) = CC1_b * DD2_b - CC2_b * DD1_b;
		}

	else if (No_of_Layers >= 3)
		{
			double AA1_i, BB1_i, CC1_i, DD1_i, AA3_i, BB3_i, CC3_i, DD3_i, AA2_i, AA2D_i, CC2_i, CC2D_i, BB2, DD2;
			AA1_i = (k(No_of_nodes(0) + No_of_nodes(1)) + k(No_of_nodes(0) + No_of_nodes(1) + 1)) / (2 * pow(Inverse_nodes(1), 2));
			BB1_i = -(k(No_of_nodes(0) + No_of_nodes(1)) + 3 * k(No_of_nodes(0) + No_of_nodes(1) + 1)) / (2 * pow(Inverse_nodes(1), 2)) - (rho(No_of_nodes(0) + No_of_nodes(1) + 1) * Cp(No_of_nodes(0) + No_of_nodes(1) + 1) / delt) * Layer_thickness(1) * Layer_thickness(1);
			CC1_i = k(No_of_nodes(0) + No_of_nodes(1) + 1) / (1 * pow(Inverse_nodes(1), 2));
			DD1_i = -(rho(No_of_nodes(0) + No_of_nodes(1) + 1) * Cp(No_of_nodes(0) + No_of_nodes(1) + 1) / delt) * T(No_of_nodes(0) + No_of_nodes(1)) * Layer_thickness(1) * Layer_thickness(1) - SS(No_of_nodes(0) + No_of_nodes(1)) * Layer_thickness(1) * Layer_thickness(1);

			if (Input_Flag.Coordinate != 0)
			{

				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(AA1_i, BB1_i, CC1_i, k(No_of_nodes(0) + No_of_nodes(1) + 1), Inverse_nodes(1), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(AA1_i, CC1_i, k(No_of_nodes(0) + No_of_nodes(1) + 1), Layer_thickness(1), Inverse_nodes(1), Outer_radius_instantaneous, Input_Flag);
				}

			}

			AA3_i = k(No_of_nodes(0) + No_of_nodes(1) + 2) / (1 * pow(Inverse_nodes(2), 2));
			BB3_i = -(k(No_of_nodes(0) + No_of_nodes(1) + 3) + 3 * k(No_of_nodes(0) + No_of_nodes(1) + 2)) / (2 * pow(Inverse_nodes(2), 2)) - (rho(No_of_nodes(0) + No_of_nodes(1) + 2) * Cp(No_of_nodes(0) + No_of_nodes(1) + 2) / delt) * Layer_thickness(2) * Layer_thickness(2);
			CC3_i = (k(No_of_nodes(0) + No_of_nodes(1) + 2) + k(No_of_nodes(0) + No_of_nodes(1) + 3)) / (2 * pow(Inverse_nodes(2), 2));
			DD3_i = -((rho(No_of_nodes(0) + No_of_nodes(1) + 2) * Cp(No_of_nodes(0) + No_of_nodes(1) + 2) / delt) * T(No_of_nodes(0) + No_of_nodes(1)) * Layer_thickness(2) * Layer_thickness(2)) - SS(No_of_nodes(0) + No_of_nodes(1)) * Layer_thickness(2) * Layer_thickness(2);

			if (Input_Flag.Coordinate != 0)
			{

				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(AA3_i, BB3_i, CC3_i, k(No_of_nodes(0) + No_of_nodes(1) + 2), Inverse_nodes(2), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(AA3_i, CC3_i, k(No_of_nodes(0) + No_of_nodes(1) + 2), Layer_thickness(2), Inverse_nodes(2), Outer_radius_instantaneous, Input_Flag);
				}

			}




			AA2_i = -(k(No_of_nodes(0) + No_of_nodes(1) + 1)) / (2 * Inverse_nodes(1) * Layer_thickness(1));
			AA2D_i = k(No_of_nodes(0) + No_of_nodes(1) + 2) / (2 * Inverse_nodes(2) * Layer_thickness(2));
			CC2_i = -AA2D_i;
			CC2D_i = -AA2_i;


			A(No_of_nodes(0) + No_of_nodes(1), No_of_nodes(0) + No_of_nodes(1) - 1) = AA1_i * CC2D_i * AA3_i - CC1_i * AA2_i * AA3_i;
			A(No_of_nodes(0) + No_of_nodes(1), No_of_nodes(0) + No_of_nodes(1)) = BB3_i * CC1_i * AA2D_i + BB1_i * CC2D_i * AA3_i;
			A(No_of_nodes(0) + No_of_nodes(1), No_of_nodes(0) + No_of_nodes(1) + 1) = CC1_i * AA2D_i * CC3_i - AA3_i * CC1_i * CC2_i;
			B(No_of_nodes(0) + No_of_nodes(1), 0) = DD3_i * CC1_i * AA2D_i + AA3_i * CC2D_i * DD1_i;
    }
}
    }

if(No_of_Layers>=3)
{

	if (MPD == 0 && Layer_thickness(0) == 0 && Layer_thickness(1) == 0 && No_of_Layers >= 3)
	{
		AA2_s = k(No_of_nodes(0) + No_of_nodes(1) + 2) / (pow(Inverse_nodes(2), 2));
		BB2_s = -(3 * k(No_of_nodes(0) + No_of_nodes(1) + 2) + k(No_of_nodes(0) + No_of_nodes(1) + 3)) / (2 * pow(Inverse_nodes(2), 2)) - (((rho(No_of_nodes(0) + No_of_nodes(1) + 2) * Cp(No_of_nodes(0) + No_of_nodes(1) + 2)) / delt) * Layer_thickness(2) * Layer_thickness(2));
		CC2_s = (k(No_of_nodes(0) + No_of_nodes(1) + 2) + k(No_of_nodes(0) + No_of_nodes(1) + 3)) / (2 * pow(Inverse_nodes(2), 2));
		DD2_s = -((rho(No_of_nodes(0) + No_of_nodes(1) + 2) * Cp(No_of_nodes(0) + No_of_nodes(1) + 2) / delt) * T(No_of_nodes(0) + No_of_nodes(1)) * Layer_thickness(2) * Layer_thickness(2)) - SS(No_of_nodes(0) + No_of_nodes(1)) * Layer_thickness(2) * Layer_thickness(2);



		if (Input_Flag.Coordinate != 0)
		{

			if (Outer_radius_instantaneous <= 0.0000001)
			{
				CYSP2(AA2_s, BB2_s, CC2_s, k(No_of_nodes(0) + No_of_nodes(1) + 2), Inverse_nodes(2), Input_Flag);
			}
			else if (Outer_radius_instantaneous > 0.0000001)
			{
				CYSP1(AA2_s, CC2_s, k(No_of_nodes(0) + No_of_nodes(1) + 2), Layer_thickness(2), Inverse_nodes(2), Outer_radius_instantaneous, Input_Flag);
			}

		}

		AA1_s = (k(No_of_nodes(0) + No_of_nodes(1) + 2)) / (2 * Inverse_nodes(2) * Layer_thickness(2));
		BB1_s = heat_transfer_coefficient_outer;
		CC1_s = -(k(No_of_nodes(0) + No_of_nodes(1) + 2)) / (2 * Inverse_nodes(2) * Layer_thickness(2));
		DD1_s = (heat_transfer_coefficient_outer * Tg - epsilon(No_of_nodes(0) + No_of_nodes(1) + 2) * sigma * pow(T(No_of_nodes(0) + No_of_nodes(1)), 4) + Qradiation);



		A(No_of_nodes(0) + No_of_nodes(1), No_of_nodes(0) + No_of_nodes(1) - 1) = 0;
		A(No_of_nodes(0) + No_of_nodes(1), No_of_nodes(0) + No_of_nodes(1)) = BB1_s * AA2_s - AA1_s * BB2_s;
		A(No_of_nodes(0) + No_of_nodes(1), No_of_nodes(0) + No_of_nodes(1) + 1) = AA2_s * CC1_s - AA1_s * CC2_s;
		B(No_of_nodes(0) + No_of_nodes(1), 0) = AA2_s * DD1_s - AA1_s * DD2_s;
	}
//
	for (int j = 3; j <= No_of_Layers; j++)
	{
		VectorXi Node_till_j;
		int Sum_Node_till_j;
		Node_till_j = No_of_nodes.segment(0, j);
		Sum_Node_till_j = Node_till_j.sum();
		for (int ioi = Sum_Node_till_j - No_of_nodes(j - 1) + 1; ioi < Sum_Node_till_j; ioi++)
		{
//			A(ioi, ioi - 1) = (k(ioi + j - 3) + k(ioi + j - 2)) / (2 * pow(Inverse_nodes(j - 1) * Layer_thickness(j - 1), 2));
//			A(ioi, ioi) = -(k(ioi + j - 3) + 2 * k(ioi + j - 2) + k(ioi + j - 1)) / (2 * pow(Inverse_nodes(j - 1) * Layer_thickness(j - 1), 2)) - ((rho(ioi + j - 2) * Cp(ioi + j - 2)) / delt);
//			A(ioi, ioi + 1) = (k(ioi + j - 2) + k(ioi + j - 1)) / (2 * pow(Inverse_nodes(j - 1) * Layer_thickness(j - 1), 2));
//			B(ioi, 0) = -((rho(ioi + j - 2) * Cp(ioi + j - 2)) / delt) * T(ioi) - SS(ioi);

            A(ioi, ioi - 1) = (k(ioi + j - 2) + k(ioi + j - 1)) / (2 * pow(Inverse_nodes(j - 1) , 2));
			A(ioi, ioi) = -(k(ioi + j - 2) + 2 * k(ioi + j - 1) + k(ioi + j )) / (2 * pow(Inverse_nodes(j - 1) , 2)) - ((rho(ioi + j - 1) * Cp(ioi + j - 1)) / delt)*pow(Layer_thickness(j - 1),2);
			A(ioi, ioi + 1) = (k(ioi + j - 1) + k(ioi + j )) / (2 * pow(Inverse_nodes(j - 1) , 2));
			B(ioi, 0) = -((rho(ioi + j - 1) * Cp(ioi + j - 1)) / delt) * pow(Layer_thickness(j - 1),2)*T(ioi) - SS(ioi)*pow(Layer_thickness(j - 1),2);


//			//
			if (Input_Flag.Coordinate != 0)
			{
				Outer_radius_instantaneous = Outer_radius_instantaneous - Layer_thickness(j - 1) * Inverse_nodes(j - 1);
				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(A(ioi, ioi - 1), A(ioi, ioi), A(ioi, ioi + 1), k(ioi + j - 2), Inverse_nodes(j - 1), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(A(ioi, ioi - 1), A(ioi, ioi + 1), k(ioi + j - 2), Layer_thickness(j - 1), Inverse_nodes(j - 1), Outer_radius_instantaneous, Input_Flag);
				}

			}
//
	}

		Outer_radius_instantaneous = Outer_radius_instantaneous - Layer_thickness(j - 1) * Inverse_nodes(j - 1);

		if (j != No_of_Layers)
		{
			double AA1_i, BB1_i, CC1_i, DD1_i, AA3_i, BB3_i, CC3_i, DD3_i, AA2_i, AA2D_i, CC2_i, CC2D_i, BB2, DD2;


			AA1_i = (k(Sum_Node_till_j + j - 1) + k(Sum_Node_till_j + j - 2)) / (2 * pow(Inverse_nodes(j - 1) , 2));
			BB1_i = -(k(Sum_Node_till_j + j - 2) + 3 * k(Sum_Node_till_j + j - 1)) / (2 * pow(Inverse_nodes(j - 1) , 2)) - ((rho(Sum_Node_till_j + j - 1) * Cp(Sum_Node_till_j + j - 1)) / delt)*pow(Layer_thickness(j - 1),2);
			CC1_i = k(Sum_Node_till_j + j - 1) / (pow(Inverse_nodes(j - 1) , 2));
			DD1_i = -((rho(Sum_Node_till_j + j - 1) * Cp(Sum_Node_till_j + j - 1)) / delt)*pow(Layer_thickness(j - 1),2) * T(Sum_Node_till_j) - SS(Sum_Node_till_j)*pow(Layer_thickness(j - 1),2);

			if (Input_Flag.Coordinate != 0)
			{

				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(AA1_i, BB1_i, CC1_i, k(Sum_Node_till_j + j - 1), Inverse_nodes(j - 1), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(AA1_i, CC1_i, k(Sum_Node_till_j + j - 1), Layer_thickness(j - 1), Inverse_nodes(j - 1), Outer_radius_instantaneous, Input_Flag);
				}

			}




			AA3_i = k(Sum_Node_till_j + j) / (pow(Inverse_nodes(j) , 2));
			BB3_i = -(k(Sum_Node_till_j + j + 1) + 3 * k(Sum_Node_till_j + j)) / (2 * (pow(Inverse_nodes(j) , 2))) - ((rho(Sum_Node_till_j + j) * Cp(Sum_Node_till_j + j)) / delt)*pow(Layer_thickness(j),2);
			CC3_i = (k(Sum_Node_till_j + j) + k(Sum_Node_till_j + j + 1)) / (2 * (pow(Inverse_nodes(j), 2)));
			DD3_i = -((rho(Sum_Node_till_j + j) * Cp(Sum_Node_till_j + j)) / delt)*pow( Layer_thickness(j),2) * T(Sum_Node_till_j) - SS(Sum_Node_till_j)*pow( Layer_thickness(j),2);


			if (Input_Flag.Coordinate != 0)
			{

				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(AA3_i, BB3_i, CC3_i, k(Sum_Node_till_j + j), Inverse_nodes(j), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(AA3_i, CC3_i, k(Sum_Node_till_j + j), Layer_thickness(j), Inverse_nodes(j), Outer_radius_instantaneous, Input_Flag);
				}

			}




			AA2_i = -(k(Sum_Node_till_j + j - 1) / (2 * Inverse_nodes(j - 1) * Layer_thickness(j - 1)));
			AA2D_i = k(Sum_Node_till_j + j) / (2 * Inverse_nodes(j) * Layer_thickness(j));
			CC2_i = -AA2D_i;
			CC2D_i = -AA2_i;

			A(Sum_Node_till_j, Sum_Node_till_j - 1) = AA1_i * CC2D_i * AA3_i - CC1_i * AA2_i * AA3_i;
			A(Sum_Node_till_j, Sum_Node_till_j) = BB3_i * CC1_i * AA2D_i + BB1_i * CC2D_i * AA3_i;
			A(Sum_Node_till_j, Sum_Node_till_j + 1) = CC1_i * AA2D_i * CC3_i - AA3_i * CC1_i * CC2_i;
			B(Sum_Node_till_j, 0) = DD3_i * CC1_i * AA2D_i + AA3_i * CC2D_i * DD1_i;
		}
////
		if (j == No_of_Layers)
		{
			double AA2_b, BB2_b, CC2_b, DD2_b, AA1_b, BB1_b, CC1_b, DD1_b;
//			AA2_b = (k(No_of_nodes.sum() + No_of_Layers - 1) + k(No_of_nodes.sum() + No_of_Layers - 2)) / (2 * pow(Inverse_nodes(No_of_Layers - 1) * Layer_thickness(No_of_Layers - 1), 2));
//			BB2_b = -(3 * k(No_of_nodes.sum() + No_of_Layers - 1) + k(No_of_nodes.sum() + No_of_Layers - 2)) / (2 * pow(Inverse_nodes(No_of_Layers - 1) * Layer_thickness(No_of_Layers - 1), 2)) - (rho(No_of_nodes.sum() + No_of_Layers - 1) * Cp(No_of_nodes.sum() + No_of_Layers - 1)) / delt;
//			CC2_b = k(No_of_nodes.sum() + No_of_Layers - 1) / (1 * pow(Inverse_nodes(No_of_Layers - 1) * Layer_thickness(No_of_Layers - 1), 2));
//			DD2_b = -(rho(No_of_nodes.sum() + No_of_Layers - 1) * Cp(No_of_nodes.sum() + No_of_Layers - 1) / delt) * T(No_of_nodes.sum()) - SS(No_of_nodes.sum());

            AA2_b = (k(No_of_nodes.sum() + No_of_Layers - 1) + k(No_of_nodes.sum() + No_of_Layers - 2)) / (2 * pow(Inverse_nodes(No_of_Layers - 1),2));
			BB2_b = -(3 * k(No_of_nodes.sum() + No_of_Layers - 1) + k(No_of_nodes.sum() + No_of_Layers - 2)) / (2 * pow(Inverse_nodes(No_of_Layers - 1),2)) - ((rho(No_of_nodes.sum() + No_of_Layers - 1) * Cp(No_of_nodes.sum() + No_of_Layers - 1)) / delt)* pow(Layer_thickness(No_of_Layers - 1), 2);
			CC2_b = k(No_of_nodes.sum() + No_of_Layers - 1) / (1 * pow(Inverse_nodes(No_of_Layers - 1),2));
			DD2_b = -((rho(No_of_nodes.sum() + No_of_Layers - 1) * Cp(No_of_nodes.sum() + No_of_Layers - 1) / delt))*pow(Layer_thickness(No_of_Layers - 1), 2) *T(No_of_nodes.sum()) - SS(No_of_nodes.sum())* pow(Layer_thickness(No_of_Layers - 1), 2);


			if (Input_Flag.Coordinate != 0)
			{

				if (Outer_radius_instantaneous <= 0.0000001)
				{
					CYSP2(AA2_b, BB2_b, CC2_b, k(No_of_nodes.sum() + No_of_Layers - 1), Inverse_nodes(j - 1), Input_Flag);
				}
				else if (Outer_radius_instantaneous > 0.0000001)
				{
					CYSP1(AA2_b, CC2_b, k(No_of_nodes.sum() + No_of_Layers - 1), Layer_thickness(j - 1), Inverse_nodes(j - 1), Outer_radius_instantaneous, Input_Flag);
				}

			}


			if(Back_wall_Convection_ON ==1)
            {
             FreeConvection_Surface(T(No_of_nodes.sum()),T_Ambient_Convection, h_convection_backwall, Characteristic_Length_backwall_convection, Sea_Level_Pressure, Use_Correlation_or_value_backwall_convection);
            }
            else
            {
             h_convection_backwall=0;
            }

            double h_radiation_loss_backwall;

            if(Backwall_wall_Radiation_loss_ON==1)
            {
            h_radiation_loss_backwall = sigma*epsilon(No_of_nodes.sum())*(pow(T(No_of_nodes.sum()),3) + pow(T(No_of_nodes.sum()),2)*T_Ambient_Radiation + T(No_of_nodes.sum())*pow(T_Ambient_Radiation,2) + pow(T_Ambient_Radiation,3)  );

            }
            else
            {
                h_radiation_loss_backwall =0;
            }

			AA1_b = k(No_of_nodes.sum() + No_of_Layers - 1) / (2 * Inverse_nodes(No_of_Layers - 1) * Layer_thickness(No_of_Layers - 1));
			BB1_b =  h_convection_backwall + h_radiation_loss_backwall + Propellant_Mass/delt;
			CC1_b = -k(No_of_nodes.sum() + No_of_Layers - 1) / (2 * Inverse_nodes(No_of_Layers - 1) * Layer_thickness(No_of_Layers - 1));
			DD1_b = Q_RADIATION_BACKWALL + h_convection_backwall*T_Ambient_Convection + h_radiation_loss_backwall*T_Ambient_Radiation + (Propellant_Mass *T(No_of_nodes.sum()))/delt  ;

			A(No_of_nodes.sum(), No_of_nodes.sum() - 1) = CC1_b * AA2_b - CC2_b * AA1_b;
			A(No_of_nodes.sum(), No_of_nodes.sum()) = CC1_b * BB2_b - CC2_b * BB1_b;
			B(No_of_nodes.sum(), 0) = CC1_b * DD2_b - CC2_b * DD1_b;
		}
}
}

if(No_of_Layers<2)
{
	if (Layer_thickness(0) != 0)
	{
		MatrixXd A1, B1;
		VectorXd T1;
		A1 = MatrixXd::Zero(No_of_nodes.sum() + 1, No_of_nodes.sum() + 1);
		B1 = MatrixXd::Zero(No_of_nodes.sum() + 1, 1);
		T1 = VectorXd::Zero(No_of_nodes.sum() + 1);
		A1 = A;
		B1 = B;
		T1 = A1.colPivHouseholderQr().solve(B1);
        //T1=A1.lu().solve(B1);
		T=T1;
		//cout << A1 << endl;
       //cout << T1 << endl;
	}
}
	if (No_of_Layers>=2)
    {
    if (Layer_thickness(0) != 0)
	{
		MatrixXd A1, B1;
		VectorXd T1;
		A1 = MatrixXd::Zero(No_of_nodes.sum() + 1, No_of_nodes.sum() + 1);
		B1 = MatrixXd::Zero(No_of_nodes.sum() + 1, 1);
		T1 = VectorXd::Zero(No_of_nodes.sum() + 1);
		A1 = A;
		B1 = B;
		T1 = A1.colPivHouseholderQr().solve(B1);

		T=T1;

	}
	else if (Layer_thickness(0) == 0 && Layer_thickness(1) != 0)
	{
        MatrixXd A1, B1;
		VectorXd T1;
		A1 = MatrixXd::Zero(No_of_nodes.sum() + 1 - No_of_nodes(0), No_of_nodes.sum() + 1 - No_of_nodes(0));
		B1 = MatrixXd::Zero(No_of_nodes.sum() + 1 - No_of_nodes(0), 1);


		T1 = VectorXd::Zero(No_of_nodes.sum() + 1 - No_of_nodes(0), 1);
		A1 = A.block(No_of_nodes(0), No_of_nodes(0), No_of_nodes.sum() + 1 - No_of_nodes(0), No_of_nodes.sum() + 1 - No_of_nodes(0));
		B1 = B.block(No_of_nodes(0), 0, No_of_nodes.sum() + 1 - No_of_nodes(0), 1);

		T1 = A1.colPivHouseholderQr().solve(B1);
		//cout << T1 << endl;
      T.segment(No_of_nodes(0),No_of_nodes.sum() + 1 - No_of_nodes(0))=T1;

	}
	else
	{
		MatrixXd A1, B1;
		VectorXd T1;
		A1 = MatrixXd::Zero(No_of_nodes.sum() + 1 - No_of_nodes(0) - No_of_nodes(1), No_of_nodes.sum() + 1 - No_of_nodes(0) - No_of_nodes(1));
		B1 = MatrixXd::Zero(No_of_nodes.sum() + 1 - No_of_nodes(0) - No_of_nodes(1), 1);
		T1 = VectorXd::Zero(No_of_nodes.sum() + 1 - No_of_nodes(0) - No_of_nodes(1), 1);
		A1 = A.block(No_of_nodes(0) + No_of_nodes(1), No_of_nodes(0) + No_of_nodes(1), No_of_nodes.sum() + 1 - No_of_nodes(0) - No_of_nodes(1), No_of_nodes.sum() + 1 - No_of_nodes(0) - No_of_nodes(1));
		B1 = B.block(No_of_nodes(0) + No_of_nodes(1), 0, No_of_nodes.sum() + 1 - No_of_nodes(0) - No_of_nodes(1), 1);
		T1 = A1.colPivHouseholderQr().solve(B1);
        T.segment(No_of_nodes(0) + No_of_nodes(1),No_of_nodes.sum() + 1 - No_of_nodes(0) - No_of_nodes(1))=T1;

	}
   }



}



// Get instantaneous mdot_p and mdot_c and Layer thickness
void Instantaneous_MassRate_Thickness(struct Heat_Flux_Convective& HF_Convective, double Qradiation, VectorXi No_of_nodes, VectorXd Inverse_nodes, VectorXd& Layer_thickness, VectorXd epsilon, double Temp_Ablation, double Temp_Pyrolysis, double Heat_of_Pyrolysis, double Heat_of_Ablation, double Density_of_Virgin, double Density_of_Char, double Density_of_Pyrolysis_gas, VectorXd& T, VectorXd& Tinitial, double& delt, double& Mass_rate_Char, double& Mass_rate_Pyrolysis, struct Input_Flag& Input_Flag, double X1_Thin, double X2_Thin, double Tolerance, VectorXd k)
{

	double sigma, MPD, MCD;
	sigma = 5.67 * pow(10, -8);
	MPD = Mass_rate_Pyrolysis;
	MCD = Mass_rate_Char;
	if (T(0) < Temp_Ablation - Tolerance || Layer_thickness(0) == 0 || Input_Flag.Sublime == 1)
	{
		MCD = 0;
	}
	else
	{
		double TT, Choice_1;
		TT = (4 * T(1) - 3 * Temp_Ablation - T(2)) / (2 * Inverse_nodes(0));
		if (Layer_thickness(0) < X1_Thin)
		{
			TT = T(1) - Temp_Ablation;
		}
		Choice_1 = HF_Convective.q_aero_net + Qradiation - epsilon(0) * sigma * (pow(Temp_Ablation, 4)) + (k(0) * TT) / Layer_thickness(0);
		MCD = max(Choice_1, 10.0);
		MCD = MCD / Heat_of_Ablation;
	}


	if (((T(No_of_nodes(1)) < Temp_Pyrolysis - Tolerance) && MPD == 0) || Layer_thickness(1) == 0)
	{
		MPD = 0;
	}

	else
	{
		if (Layer_thickness(1) == 0)
		{
			double TT, Choice_1;
			MPD = HF_Convective.q_aero_net + Qradiation - epsilon(No_of_nodes(1) + 1) * sigma * (pow(Temp_Pyrolysis, 4));
			TT = (-4 * T(No_of_nodes(0) + 1) + 3 * Temp_Pyrolysis + T(No_of_nodes(0) + 2)) / (2 * Inverse_nodes(1));
			Choice_1 = k(No_of_nodes(1) + 1) * TT;
			MPD = MPD - min(MPD, Choice_1 / Layer_thickness(1));
			MPD = MPD / Heat_of_Pyrolysis;

		}

		else
		{

			double TT, Choice_1;
			TT = (4 * T(No_of_nodes(0) - 1) - 3 * Temp_Pyrolysis - T(No_of_nodes(0) - 2)) / (2 * Inverse_nodes(0));
			MPD = (k(No_of_nodes(0)) * TT) / Layer_thickness(0);
			TT = (-4 * T(No_of_nodes(0) + 1) + 3 * Temp_Pyrolysis + T(No_of_nodes(0) + 2)) / (2 * Inverse_nodes(1));
			Choice_1 = k(No_of_nodes(1) + 1) * TT;
			MPD = MPD - min(MPD, Choice_1 / Layer_thickness(1));
			MPD = MPD / Heat_of_Pyrolysis;
		}

		if (Input_Flag.Sublime = 1)
		{
			double VAL;
			Layer_thickness(0) = 0;
			VAL = ((Mass_rate_Pyrolysis + MPD) * delt) / (2 * (Density_of_Virgin - Density_of_Char));
			Layer_thickness(1) = Layer_thickness(1) - VAL;

		}
		else
		{
			double VAL, VAL1;
			VAL = ((Mass_rate_Pyrolysis + MPD) * delt) / (2 * (Density_of_Virgin - Density_of_Char));
			Layer_thickness(1) = Layer_thickness(1) - VAL;
			VAL1 = ((Mass_rate_Char + MCD) * delt) / (2 * (Density_of_Pyrolysis_gas));
			Layer_thickness(0) = Layer_thickness(0) + VAL - VAL1;
		}

	}

	Mass_rate_Pyrolysis = MPD;
	Mass_rate_Char = MCD;


}



// For linear interpolation
void Linear_Interpolation(double X1, double& Y1, int No_of_points, MatrixXd X, MatrixXd Y)
{
	int num_req;
	for (int num = 1; num < No_of_points; num++)
	{
		if (X1 < X(num, 0))
		{
			num_req = num;
			break;
		}
		num_req = num;
	}
	num_req = num_req - 1;
	Y1 = Y(num_req, 0) + ((Y(num_req + 1, 0) - Y(num_req, 0)) / (X(num_req + 1, 0) - X(num_req, 0))) * (X1 - X(num_req, 0));
}




//////////////////// ----------MAIN EXECUTION FUNCTION STARTS HERE-------------------//////////////////


int main()
{
    double Gamma =1.4;
    double Cp_Pyrolysis_gas=0;
    double Sea_Level_Pressure=101325;

  Input_Flag Input_Flag_input;
  Input_Flag_input.Convective_data=0; //0: Trajectory, 1: User input h & Tg, 2: Wind_Tunnel Data , 3: CFD Data
  Input_Flag_input.Mach_input=0;   //0: Velocity as input from Trajectory, 1: Mach number as input from Trajectory
  Input_Flag_input.Perturbation_on_Properties=0;
  Input_Flag_input.Axisymmetric=1;
  Input_Flag_input.Coordinate=0;      //0: Cartesian, 1: Cylindrical, 2: Spherical
  Input_Flag_input.No_of_components=3;
  Input_Flag_input.No_Thermal_response=0;
  Input_Flag_input.Inviscid_Flag = 2;  //1: Full Pressure Recovery, Cp=0, 2: Cp from user input
  int No_of_lines_Location=24;
  int No_of_lines_Mach=12;
  Input_Flag_input.Geometry=2;
  Input_Flag_input.Full_turbulent=0;
  Input_Flag_input.Re_transition_criteria=0;   //0: based on wetted length, 1: based on Re_theta
  Input_Flag_input.Eckert=0;
  Input_Flag_input.VanDriest=1;
  Input_Flag_input.Is_Cone=0;
  Input_Flag_input.Sublime=1;
  Input_Flag_input.Uniform_Initial_Temperature=1;   //0: for Non-uniform initial temperature, 1: for Uniform Initial Temperature
  Input_Flag_input.Thickness_to_be_optimized=0;
  Input_Flag_input.Air_Gap_Layer=0;
  Input_Flag_input.Shock_characteristics=2; //0: No Shock, 1: Ideal, 2: real
  Input_Flag_input.Index_of_Layer_where_thickness_to_be_optimized=2;
  Input_Flag_input.Index_of_Node_where_temperature_constraint_to_be_maintained=0;
  Input_Flag_input.Temp_constarint_to_be_maintained=0;
  Input_Flag_input.Tolerance_Temperature_constraint=1;
  double DX_OPTIMIZED=0;
  double h_convection_air_gap,h_radiation_air_gap,AIR_GAP_THICKNESS, LENGTH_OVER_WHICH_AIR_GAP,Emmisivity_1,Emmisivity_2;
  double Analysis_Location = 7.1;
  double Reference_length=0.7;
  double Theta=0;
Trajectory Traj;
UserInput_Convective_Flux User_Input_h_Tg;
Properties Freestream;
Properties Downstream_Ideal;
Properties Downstream_Real;
Properties Downstream_Total;
Properties Edge;
Properties wall;
double Coefficient_of_Pressure;
Heat_Flux_Convective HF_Convective;
double Kn_Bridging_Factor;
    double Temperature_recovery;
  	double Running_length=7;
  	double IC=0;

int Use_Correlation_or_value_backwall_convection;
double T_Ambient_Convection,h_convection_backwall, Characteristic_Length_backwall_convection, Q_RADIATION_BACKWALL, T_Ambient_Radiation;
double Back_wall_Convection_ON,Backwall_wall_Radiation_loss_ON;

	double Time_start, Time_end;
	double delt,delt_store;
	double time;
	int TIME_STEP_REDUCED_ITERATION=0;
    int INNER_ITER = 0;
	int CONVERGENCE_CONDITIONS_MET = 0;
	int TOLERANCE_1 = 1;
	int IXFIST=0;
	int NODES_1;
	double T_wall;
	int Boundary_Node;
	int GONE_IN_TIME_STEP_REDUCTION=0;


    Time_start = 0;
	Time_end = 250;


   double Knudsen_number;
   int Flow_Regime; //0: continumm, 1: Tarnsition, 2 : Free Molecular
//
	int STORED_ARRAY_ID=0;
double time_store;

   int No_of_Layers = 3;
    VectorXi No_of_nodes(No_of_Layers);
	VectorXd Inverse_nodes(No_of_Layers);
	VectorXi Material_Index(No_of_Layers);

	VectorXd Initial_Layer_thickness(No_of_Layers);
	double Layer_thickness_OPTIMIZED_PREVIOUS_ITERATION;
	VectorXd Layer_thickness(No_of_Layers);

double T_MAX,T_MAX1,T_MAX2;

	Initial_Layer_thickness << 0.0000,0.001,0.002;
    No_of_nodes << 10,10,10;
    Material_Index << 5,5,1;

  	VectorXd TIME_STORED;
	MatrixXd TEMP_STORED;
	TIME_STORED=VectorXd::Constant(1000,0);
	TEMP_STORED=MatrixXd::Zero(1000, No_of_nodes.sum() + 1);
   int Transition_based_on_Retheta=0;

   double  heat_transfer_coefficient_outer,Tg;

	double Re_transition_criteria=0;
	double Rey_No_Edge1=0;
VectorXd Tinitial;


  	double Re_transition = 1000000;
	double RETS = 0;

    int No_of_lines, No_of_columns;
	No_of_lines = 251;
	No_of_columns = 7;
	MatrixXd Input(No_of_lines, No_of_columns);
    MatrixXd Time_input(No_of_lines, 1), Altitude_input(No_of_lines, 1), Velocity_input(No_of_lines, 1);

if(Input_Flag_input.Convective_data==0)
	{

	Input << 0, 23.8, 0, 0, 0, 0, 0,
		1, 24.2, 3.81, 0.011, 8.5, 59.14, 8.73,
		2, 29.3, 8.74, 0.025, 44.5, 22.19, 17.25,
		3, 40.5, 14.68, 0.042, 125.5, 13.3, 29.12,
		4, 58.1, 21.19, 0.061, 261, 9.49, 43.21,
		5, 82.6, 28.27, 0.081, 463.6, 7.43, 60.09,
		6, 114.4, 35.9, 0.103, 745.6, 6.19, 80.54,
		7, 154.2, 44.1, 0.127, 1120.8, 5.38, 105.3,
		8, 202.5, 52.86, 0.152, 1603.8, 4.05, 113.49,
		9, 259.9, 62.27, 0.18, 2213.5, 2.91, 112.47,
		10, 326.9, 72.29, 0.209, 2965.3, 2.45, 126.8,
		11, 404.2, 82.92, 0.239, 3872.9, 2.26, 152.84,
		12, 492.2, 94.12, 0.272, 4948.9, 2.37, 205.1,
		13, 591.4, 105.81, 0.306, 6196.9, 2.65, 286.62,
		14, 702.2, 117.86, 0.341, 7607.8, 3.27, 434.61,
		15, 824.8, 130.36, 0.378, 9198.8, 3.99, 641.02,
		16, 959.6, 143.52, 0.417, 11002.7, 4.26, 817.17,
		17, 1106.8, 157.48, 0.458, 13067.1, 3.98, 907.52,
		18, 1266.8, 171.78, 0.501, 15320.4, 3.72, 993.53,
		19, 1439.7, 186, 0.543, 17672.4, 3.26, 1004.43,
		20, 1625.2, 200.2, 0.586, 20112.9, 2.64, 926.13,
		21, 1823.2, 214.16, 0.628, 22577.2, 2.07, 816.21,
		22, 2033.3, 227.48, 0.668, 24949.7, 1.41, 612.86,
		23, 2255.3, 240.93, 0.709, 27380.8, 0.65, 309.72,
		24, 2489.3, 254.23, 0.75, 29774.5, 0.3, 158.23,
		25, 2735, 267.18, 0.79, 32058.5, 0.48, 268.49,
		26, 2993.5, 283.33, 0.839, 35074.9, 0.4, 242.62,
		27, 3266.8, 300.11, 0.891, 38303.6, 0.64, 424.97,
		28, 3554.5, 316.47, 0.942, 41371.3, 0.62, 446.43,
		29, 3856.4, 332.63, 0.993, 44287.1, 0.65, 499.19,
		30, 4171.7, 348.18, 1.043, 46980, 0.87, 712.91,
		31, 4499.8, 364.37, 1.095, 49763.2, 0.57, 492.17,
		32, 4840.1, 378.95, 1.142, 51931.6, 0.45, 412.3,
		33, 5192.3, 394.07, 1.192, 54135.7, 0.18, 168.86,
		34, 5556.2, 407.76, 1.238, 55817.5, 0.45, 443.21,
		35, 5931.5, 420.12, 1.281, 56906.7, 0.92, 915.67,
		36, 6318.1, 435.44, 1.333, 58717, 0.49, 505.21,
		37, 6716, 450.18, 1.384, 60145, 0.29, 306.82,
		38, 7125.4, 465.04, 1.437, 61402.9, 0.28, 299.79,
		39, 7546.5, 480.19, 1.491, 62655, 0.14, 157.35,
		40, 7979.3, 494.97, 1.546, 63497.8, 0.28, 306.12,
		41, 8424.3, 508.71, 1.598, 64027.2, 0.63, 702.09,
		42, 8881.7, 525.59, 1.662, 65022.3, 0.42, 478.87,
		43, 9351.8, 544.39, 1.734, 66348, 0.3, 352.48,
		44, 9834.9, 563.05, 1.807, 67322.7, 0.42, 488.2,
		45, 10331.4, 583.59, 1.887, 68529.3, 0.23, 272.11,
		46, 10841.6, 605.48, 1.975, 69710.7, 0.21, 259.8,
		47, 11365.8, 627.7, 2.066, 70695.8, 0.37, 457.24,
		48, 11904.5, 645.13, 2.145, 70216.8, 0.53, 644.7,
		49, 12457.7, 664.79, 2.232, 70005.5, 0.95, 1156.74,
		50, 13025.7, 686.74, 2.332, 69804.3, 0.71, 870.27,
		51, 13609.2, 711.2, 2.441, 69848.9, 0.32, 387.65,
		52, 14208.5, 737.02, 2.559, 69561.4, 0.31, 381.58,
		53, 14823.9, 759.57, 2.665, 68116.2, 0.27, 322.91,
		54, 15454, 780.1, 2.761, 65808.3, 0.26, 302.92,
		55, 16097, 796.04, 2.84, 62208.3, 0.23, 254.65,
		56, 16751.4, 810.59, 2.899, 57947, 0.45, 450.38,
		57, 17415.6, 823.45, 2.939, 53126.5, 0.82, 762.99,
		58, 18088.6, 842.94, 2.991, 48853.9, 0.26, 222.57,
		59, 18770.2, 859.5, 3.028, 44676, 0.21, 164.61,
		60, 19460.2, 874.4, 3.057, 40583.7, 0.09, 63.46,
		61, 20159, 891.91, 3.093, 36963.3, 0.15, 95.77,
		62, 20866.8, 904.42, 3.123, 33573.9, 0.28, 163.91,
		63, 21583.8, 922.96, 3.172, 30892.5, 0.34, 181.51,
		64, 22310.6, 941.35, 3.217, 28289.4, 0.21, 103.6,
		65, 23047.4, 959.18, 3.259, 25781.5, 0.17, 75.57,
		66, 23794.7, 974.75, 3.293, 23476.8, 0.38, 154.05,
		67, 24552.8, 992.25, 3.337, 21457.8, 0.41, 154.52,
		68, 25321.9, 1010.83, 3.384, 19614.5, 0.32, 109.74,
		69, 26102.7, 1030.02, 3.433, 17902.6, 0.29, 89.61,
		70, 26895.4, 1050.41, 3.487, 16397, 0.43, 123.97,
		71, 27701.1, 1073.56, 3.551, 15104.9, 0.51, 133.16,
		72, 28521.2, 1099.9, 3.625, 13944.6, 0.36, 87.82,
		73, 29356.1, 1126.16, 3.697, 12828, 0.19, 43.38,
		74, 30206.1, 1150.51, 3.763, 11732, 0.16, 32.25,
		75, 31071.6, 1178.1, 3.838, 10757.5, 0.12, 23.44,
		76, 31952.8, 1212.02, 3.934, 9962.3, 0.08, 13.11,
		77, 32849.8, 1239.34, 4.007, 9107.8, 0.22, 34.59,
		78, 33761.9, 1263.38, 4.067, 8256.1, 0.21, 30.39,
		79, 34688.9, 1288.19, 4.127, 7470.3, 0.19, 25.36,
		80, 35629.7, 1316.24, 4.195, 6778, 0.07, 8.66,
		81, 36583.5, 1344.11, 4.261, 6137.9, 0.32, 33.85,
		82, 37549.6, 1370.38, 4.321, 5538.6, 0.26, 25.39,
		83, 38527.7, 1396.29, 4.38, 4993.4, 0.04, 3.87,
		84, 39517.6, 1423.12, 4.443, 4506.4, 0.1, 7.8,
		85, 40519.4, 1448.91, 4.503, 4059, 0.13, 9.02,
		86, 41533.4, 1472.83, 4.559, 3647.4, 0.2, 12.9,
		87, 42559.6, 1496.95, 4.619, 3280.1, 0.16, 8.98,
		88, 43598.5, 1520.95, 4.683, 2950.2, 0.15, 7.89,
		89, 44650.2, 1544.62, 4.747, 2650.3, 0.14, 6.6,
		90, 45715.1, 1568.57, 4.815, 2380, 0.13, 5.21,
		91, 46793.4, 1593.38, 4.887, 2137.3, 0.16, 6.02,
		92, 47885, 1618.93, 4.966, 1920.4, 0.24, 8.11,
		93, 48990.4, 1648.03, 5.06, 1732.1, 0.25, 7.58,
		94, 50110.2, 1676.61, 5.153, 1558.9, 0.23, 6.18,
		95, 51244.3, 1705.3, 5.254, 1403.3, 0.2, 4.97,
		96, 52392.7, 1734.01, 5.363, 1262.1, 0.19, 4.23,
		97, 53555.3, 1762.95, 5.48, 1133.9, 0.22, 4.26,
		98, 54732.3, 1792.15, 5.605, 1016.5, 0.22, 3.98,
		99, 55923.6, 1821.62, 5.732, 907.1, 0.19, 3.04,
		100, 57129.4, 1851.35, 5.862, 807.3, 0.18, 2.54,
		101, 58349.6, 1880.73, 6.005, 718.3, 0.16, 2.01,
		102, 59582.5, 1904.04, 6.136, 632.7, 0.16, 1.74,
		103, 60821.3, 1914.16, 6.23, 547.5, 0.16, 1.52,
		104, 62058.1, 1915.23, 6.299, 467.8, 0.17, 1.35,
		105, 63289, 1912.44, 6.346, 397.2, 0.18, 1.22,
		106, 64512.3, 1907.98, 6.389, 335.5, 0.19, 1.1,
		107, 65727.5, 1903.3, 6.428, 282.4, 0.2, 0.97,
		108, 66934.4, 1898.53, 6.47, 237.2, 0.21, 0.85,
		109, 68132.9, 1893.61, 6.521, 199.6, 0.21, 0.75,
		110, 69323, 1888.59, 6.555, 166.9, 0.22, 0.65,
		111, 70504.6, 1883.49, 6.575, 138.7, 0.24, 0.58,
		112, 71678.5, 1882.92, 6.604, 115.4, 0.36, 0.73,
		113, 72849.8, 1890.71, 6.672, 96.9, 1.13, 1.92,
		114, 74020.3, 1897.88, 6.72, 80.7, 1.15, 1.62,
		115, 75189.7, 1904.95, 6.819, 68.2, 0.58, 0.69,
		116, 76357.9, 1912.03, 6.871, 56.7, 0.3, 0.3,
		117, 77525, 1919.17, 6.929, 47.2, 0.36, 0.29,
		118, 78690.8, 1926.41, 6.988, 39.1, 0.39, 0.27,
		119, 79855.5, 1933.73, 7.048, 32.3, 0.28, 0.16,
		120, 81019.1, 1941.15, 6.831, 27.8, 0.21, 0.1,
		121, 82181.5, 1948.66, 6.879, 23.2, 1.43, 0.58,
		122, 83342.8, 1956.27, 6.93, 19.3, 4.35, 1.47,
		123, 84503, 1963.92, 6.982, 16.1, 7.26, 2.04,
		124, 85662.2, 1971.59, 7.038, 13.4, 9.58, 2.24,
		125, 86820.3, 1979.27, 7.098, 11.1, 11.76, 2.28,
		126, 87977.4, 1986.93, 7.162, 9.2, 14.14, 2.27,
		127, 89133.5, 1994.54, 7.231, 7.7, 16.62, 2.22,
		128, 90288.4, 2002.08, 7.303, 6.4, 19.01, 2.11,
		129, 91442.2, 2009.52, 7.379, 5.3, 21.32, 1.96,
		130, 92594.8, 2016.85, 7.453, 4.4, 23.63, 1.8,
		131, 93746, 2024.04, 7.523, 3.6, 25.67, 1.61,
		132, 94895.8, 2031.15, 7.589, 2.9, 27.3, 1.4,
		133, 96044.4, 2038.17, 7.641, 2.4, 28.92, 1.21,
		134, 97191.8, 2045.07, 7.673, 2, 30.69, 1.05,
		135, 98338.1, 2051.83, 7.688, 1.6, 32.48, 0.9,
		136, 99483.1, 2058.44, 7.679, 1.3, 34.2, 0.77,
		137, 100627, 2064.9, 7.643, 1, 35.91, 0.65,
		138, 101769.7, 2071.2, 7.579, 0.8, 37.62, 0.54,
		139, 102911.2, 2077.3, 7.49, 0.7, 39.33, 0.45,
		140, 104051.5, 2083.2, 7.38, 0.5, 41, 0.38,
		141, 105190.4, 2088.94, 7.251, 0.4, 41.85, 0.31,
		142, 106328.1, 2094.72, 7.109, 0.3, 41.72, 0.25,
		143, 107464.4, 2100.64, 6.956, 0.3, 41.46, 0.2,
		144, 108599.4, 2106.66, 6.796, 0.2, 41.49, 0.16,
		145, 109733.1, 2112.73, 6.631, 0.2, 41.69, 0.13,
		146, 110865.5, 2118.85, 6.466, 0.2, 41.86, 0.11,
		147, 111996.5, 2125.03, 6.303, 0.1, 41.92, 0.09,
		148, 113126.3, 2131.3, 6.146, 0.1, 41.9, 0.08,
		149, 114254.7, 2137.65, 5.995, 0.1, 41.87, 0.07,
		150, 115381.8, 2144.08, 5.845, 0.1, 41.9, 0.06,
		151, 116507.7, 2150.79, 5.701, 0.1, 41.95, 0.05,
		152, 117632.4, 2157.66, 5.564, 0.1, 42.01, 0.04,
		153, 118756, 2164.6, 5.431, 0, 42.06, 0.04,
		154, 119878.5, 2171.62, 5.306, 0, 42.08, 0.03,
		155, 120999.8, 2178.73, 5.19, 0, 42.09, 0.03,
		156, 122120, 2185.93, 5.085, 0, 42.11, 0.02,
		157, 123239, 2193.22, 4.988, 0, 42.06, 0.02,
		158, 124356.9, 2200.62, 4.902, 0, 41.9, 0.02,
		159, 125473.8, 2208.16, 4.823, 0, 41.68, 0.02,
		160, 126589.5, 2215.83, 4.75, 0, 41.47, 0.02,
		161, 127704.1, 2223.64, 4.684, 0, 41.29, 0.01,
		162, 128817.5, 2231.57, 4.623, 0, 41.18, 0.01,
		163, 129929.8, 2239.62, 4.568, 0, 41.07, 0.01,
		164, 131041, 2247.8, 4.518, 0, 40.93, 0.01,
		165, 132151, 2256.11, 4.471, 0, 40.73, 0.01,
		166, 133259.9, 2264.56, 4.429, 0, 40.52, 0.01,
		167, 134367.7, 2273.16, 4.39, 0, 40.34, 0.01,
		168, 135474.3, 2281.89, 4.354, 0, 40.19, 0.01,
		169, 136579.8, 2290.75, 4.32, 0, 40.06, 0.01,
		170, 137684.1, 2299.75, 4.29, 0, 39.92, 0.01,
		171, 138787.3, 2308.89, 4.261, 0, 39.73, 0.01,
		172, 139889.3, 2318.17, 4.235, 0, 39.52, 0.01,
		173, 140990.3, 2327.62, 4.211, 0, 39.3, 0.01,
		174, 142090, 2337.22, 4.189, 0, 39.12, 0.01,
		175, 143188.6, 2346.96, 4.169, 0, 38.99, 0.01,
		176, 144286.1, 2356.84, 4.151, 0, 38.84, 0,
		177, 145382.5, 2366.88, 4.134, 0, 38.65, 0,
		178, 146477.8, 2377.08, 4.119, 0, 38.42, 0,
		179, 147571.9, 2387.44, 4.105, 0, 38.2, 0,
		180, 148665, 2397.97, 4.093, 0, 38.02, 0,
		181, 149756.9, 2408.65, 4.082, 0, 37.88, 0,
		182, 150847.7, 2419.49, 4.073, 0, 37.72, 0,
		183, 151937.5, 2430.48, 4.064, 0, 37.51, 0,
		184, 153026.2, 2441.66, 4.055, 0, 37.26, 0,
		185, 154113.8, 2453.01, 4.05, 0, 37.02, 0,
		186, 155200.3, 2464.55, 4.043, 0, 36.83, 0,
		187, 156285.8, 2476.25, 4.04, 0, 36.68, 0,
		188, 157370.3, 2488.11, 4.036, 0, 36.53, 0,
		189, 158453.7, 2500.15, 4.033, 0, 36.34, 0,
		190, 159536.2, 2512.37, 4.031, 0, 36.09, 0,
		191, 160617.6, 2524.79, 4.03, 0, 35.83, 0,
		192, 161698.1, 2537.4, 4.029, 0, 35.61, 0,
		193, 162777.6, 2550.19, 4.029, 0, 35.45, 0,
		194, 163856.2, 2563.17, 4.031, 0, 35.31, 0,
		195, 164933.8, 2576.32, 4.033, 0, 35.13, 0,
		196, 166010.5, 2589.67, 4.035, 0, 34.89, 0,
		197, 167086.4, 2603.23, 4.038, 0, 34.62, 0,
		198, 168161.4, 2616.99, 4.042, 0, 34.38, 0,
		199, 169235.5, 2630.97, 4.047, 0, 34.19, 0,
		200, 170308.8, 2645.13, 4.053, 0, 34.05, 0,
		201, 171381.3, 2659.49, 4.058, 0, 33.87, 0,
		202, 172453, 2674.06, 4.065, 0, 33.65, 0,
		203, 173524, 2688.85, 4.072, 0, 33.38, 0,
		204, 174594.3, 2703.86, 4.079, 0, 33.13, 0,
		205, 175663.8, 2719.1, 4.087, 0, 32.93, 0,
		206, 176732.6, 2734.55, 4.096, 0, 32.77, 0,
		207, 177800.9, 2750.2, 4.105, 0, 32.61, 0,
		208, 178868.5, 2766.08, 4.115, 0, 32.39, 0,
		209, 179935.6, 2782.2, 4.125, 0, 32.11, 0,
		210, 181002.1, 2798.56, 4.136, 0, 31.85, 0,
		211, 182068.1, 2815.17, 4.148, 0, 31.64, 0,
		212, 183133.7, 2832, 4.159, 0, 31.49, 0,
		213, 184198.8, 2849.07, 4.172, 0, 31.32, 0,
		214, 185263.5, 2866.37, 4.185, 0, 31.11, 0,
		215, 186327.8, 2883.93, 4.197, 0, 30.84, 0,
		216, 187391.9, 2901.76, 4.212, 0, 30.57, 0,
		217, 188455.6, 2919.85, 4.226, 0, 30.35, 0,
		218, 189519.1, 2938.19, 4.241, 0, 30.19, 0,
		219, 190582.4, 2956.78, 4.256, 0, 30.04, 0,
		220, 191645.6, 2975.63, 4.272, 0, 29.84, 0,
		221, 192708.7, 2994.75, 4.287, 0, 29.57, 0,
		222, 193771.7, 3014.17, 4.305, 0, 29.3, 0,
		223, 194834.7, 3033.87, 4.322, 0, 29.07, 0,
		224, 195897.7, 3053.86, 4.339, 0, 28.91, 0,
		225, 196960.9, 3074.11, 4.357, 0, 28.76, 0,
		226, 198024.3, 3094.65, 4.376, 0, 28.56, 0,
		227, 199087.9, 3115.5, 4.396, 0, 28.29, 0,
		228, 200151.7, 3136.65, 4.414, 0, 28.02, 0,
		229, 201215.9, 3158.13, 4.437, 0, 27.81, 0,
		230, 202280.4, 3179.91, 4.46, 0, 27.65, 0,
		231, 203345.5, 3201.99, 4.483, 0, 27.5, 0,
		232, 204411.1, 3224.38, 4.505, 0, 27.27, 0,
		233, 205477.2, 3247.12, 4.527, 0, 26.99, 0,
		234, 206544, 3270.2, 4.55, 0, 26.73, 0,
		235, 207611.6, 3293.63, 4.571, 0, 26.54, 0,
		236, 208679.9, 3317.39, 4.593, 0, 26.41, 0,
		237, 209749.2, 3341.49, 4.614, 0, 26.26, 0,
		238, 210819.5, 3365.93, 4.639, 0, 26.02, 0,
		239, 211890.7, 3390.76, 4.666, 0, 25.73, 0,
		240, 212963, 3415.98, 4.693, 0, 25.48, 0,
		241, 214036.6, 3441.58, 4.72, 0, 25.3, 0,
		242, 215111.4, 3467.55, 4.747, 0, 25.17, 0,
		243, 216187.8, 3493.9, 4.774, 0, 25.01, 0,
		244, 217265.6, 3520.65, 4.801, 0, 24.76, 0,
		245, 218345, 3547.82, 4.827, 0, 24.49, 0,
		246, 219425.9, 3575.43, 4.853, 0, 24.25, 0,
		247, 220508.6, 3603.46, 4.882, 0, 24.09, 0,
		248, 221593.2, 3631.91, 4.914, 0, 23.95, 0,
		249, 222679.9, 3660.8, 4.945, 0, 23.77, 0,
		250, 223768.7, 3690.14, 4.977, 0, 23.49, 0;



	Time_input = Input.col(0);
	Altitude_input = Input.col(1);
	Velocity_input = Input.col(2);

}


MatrixXd h_input(No_of_lines, 1), Tg_input(No_of_lines, 1);
if(Input_Flag_input.Convective_data==1)
{

Input << 0,1,300,
        1 ,5, 300;


	Time_input = Input.col(0);
	h_input = Input.col(1);
	Tg_input = Input.col(2);
}

if(Input_Flag_input.Convective_data==2)
{

Input << 0,1,300,
        1, 5, 300;

    MatrixXd Mach_input(No_of_lines, 1), PRESS_TOTAL_input(No_of_lines, 1), TEMP_TOTAL_input(No_of_lines, 1);
	Mach_input = Input.col(0);
	PRESS_TOTAL_input = Input.col(1);
	TEMP_TOTAL_input = Input.col(2);


}

if(Input_Flag_input.Convective_data==3)
{
// Location, Pressure, Temperature, Density, Mach, Gamma
Input << 1,101325,300,1.225,1,1.225,
       2,101325,300,1.225,1,1.225;

    MatrixXd Location_input(No_of_lines, 1), Pressure_input(No_of_lines, 1), Temperature_input(No_of_lines, 1),  Density_input(No_of_lines, 1), Mach_input(No_of_lines, 1),  Gamma_input(No_of_lines, 1);
	Location_input = Input.col(0);
	Pressure_input = Input.col(1);
	Temperature_input = Input.col(2);
	Density_input = Input.col(3);
	Mach_input = Input.col(4);
	Gamma_input = Input.col(5);

}

//vector<vector<double>> COP_Table;

    double Mach_Table[No_of_lines_Mach] = { 0.0,0.800,0.900,1.050,1.200,1.500,1.800,2.000,3.000,4.000,4.750,6.000 };
	double Location_Table[No_of_lines_Location] = { 0.2,0.3,0.4,0.5,0.8,0.9,1,2,2.5,3,3.1,3.5,3.6,3.9,4.5,4.6,5.5,5.6,6.5,6.6,7.1,7.5,8.2,8.3 };
//	double COP_Table[24][12] = { {	0	,	0.54	,	0.573	,	0.715	,	0.76	,	0.828	,	0.885	,	0.79	,	0.832	,	0.841	,	0.95	,	0.95	}	,
//{	0	,	0.291	,	0.31	,	0.463	,	0.484	,	0.538	,	0.6	,	0.501	,	0.539	,	0.547	,	0.629	,	0.629	}	,
//{	0	,	0.168	,	0.179	,	0.326	,	0.298	,	0.284	,	0.353	,	0.265	,	0.319	,	0.334	,	0.414	,	0.414	}	,
//{	0	,	0.267	,	0.293	,	0.433	,	0.433	,	0.173	,	0.237	,	0.166	,	0.22	,	0.235	,	0.308	,	0.308	}	,
//{	0	,	0.337	,	0.37	,	0.511	,	0.543	,	0.409	,	0.364	,	0.243	,	0.235	,	0.228	,	0.282	,	0.282	}	,
//{	0	,	0.335	,	0.37	,	0.512	,	0.549	,	0.433	,	0.38	,	0.256	,	0.236	,	0.225	,	0.28	,	0.28	}	,
//{	0	,	0.329	,	0.369	,	0.512	,	0.554	,	0.448	,	0.39	,	0.265	,	0.236	,	0.222	,	0.278	,	0.278	}	,
//{	0	,	0.222	,	0.277	,	0.44	,	0.52	,	0.467	,	0.416	,	0.296	,	0.238	,	0.211	,	0.289	,	0.289	}	,
//{	0	,	0.113	,	0.189	,	0.37	,	0.472	,	0.47	,	0.421	,	0.301	,	0.244	,	0.217	,	0.299	,	0.299	}	,
//{	0	,	-0.237	,	-0.098	,	0.137	,	0.292	,	0.44	,	0.427	,	0.303	,	0.252	,	0.221	,	0.321	,	0.321	}	,
//{	0	,	-1.408	,	-1.094	,	-0.72	,	-0.475	,	-0.197	,	-0.071	,	-0.103	,	-0.009	,	0.018	,	0.113	,	0.113	}	,
//{	0	,	-1.126	,	-0.969	,	-0.627	,	-0.409	,	-0.194	,	-0.096	,	-0.109	,	-0.028	,	0.002	,	0.038	,	0.038	}	,
//{	0	,	-0.368	,	-0.92	,	-0.59	,	-0.381	,	-0.185	,	-0.093	,	-0.107	,	-0.029	,	0.002	,	0.035	,	0.035	}	,
//{	0	,	-0.12	,	-0.791	,	-0.495	,	-0.316	,	-0.158	,	-0.082	,	-0.101	,	-0.031	,	0	,	0.028	,	0.028	}	,
//{	0	,	-0.111	,	-0.601	,	-0.368	,	-0.232	,	-0.117	,	-0.063	,	-0.089	,	-0.029	,	-0.004	,	0.02	,	0.02	}	,
//{	0	,	-0.108	,	-0.571	,	-0.352	,	-0.222	,	-0.112	,	-0.061	,	-0.087	,	-0.029	,	-0.005	,	0.019	,	0.019	}	,
//{	0	,	-0.087	,	-0.054	,	-0.246	,	-0.154	,	-0.082	,	-0.046	,	-0.072	,	-0.031	,	-0.01	,	0.015	,	0.015	}	,
//{	0	,	-0.086	,	-0.03	,	-0.238	,	-0.148	,	-0.08	,	-0.045	,	-0.07	,	-0.031	,	-0.01	,	0.014	,	0.014	}	,
//{	0	,	-0.099	,	-0.014	,	-0.18	,	-0.111	,	-0.062	,	-0.037	,	-0.059	,	-0.029	,	-0.013	,	0.011	,	0.011	}	,
//{	0	,	-0.104	,	-0.021	,	-0.176	,	-0.108	,	-0.06	,	-0.036	,	-0.058	,	-0.029	,	-0.013	,	0.01	,	0.01	}	,
//{	0	,	-0.162	,	-0.079	,	-0.157	,	-0.096	,	-0.053	,	-0.032	,	-0.053	,	-0.028	,	-0.014	,	0.008	,	0.008	}	,
//{	0	,	-0.431	,	-0.296	,	-0.226	,	-0.134	,	-0.065	,	-0.033	,	-0.049	,	-0.027	,	-0.014	,	0.007	,	0.007	}	,
//{	0	,	0.04	,	0.038	,	-0.262	,	-0.219	,	-0.142	,	-0.11	,	-0.206	,	-0.105	,	-0.061	,	-0.022	,	-0.022	}	,
//{	0	,	0.055	,	0.074	,	-0.268	,	-0.224	,	-0.142	,	-0.113	,	-0.194	,	-0.103	,	-0.061	,	-0.018	,	-0.018	} };



MatrixXd COP_Table(No_of_lines_Location, No_of_lines_Mach);
COP_Table << 0	,	0.54	,	0.573	,	0.715	,	0.76	,	0.828	,	0.885	,	0.79	,	0.832	,	0.841	,	0.95	,	0.95	,
0	,	0.291	,	0.31	,	0.463	,	0.484	,	0.538	,	0.6	,	0.501	,	0.539	,	0.547	,	0.629	,	0.629	,
0	,	0.168	,	0.179	,	0.326	,	0.298	,	0.284	,	0.353	,	0.265	,	0.319	,	0.334	,	0.414	,	0.414	,
0	,	0.267	,	0.293	,	0.433	,	0.433	,	0.173	,	0.237	,	0.166	,	0.22	,	0.235	,	0.308	,	0.308	,
0	,	0.337	,	0.37	,	0.511	,	0.543	,	0.409	,	0.364	,	0.243	,	0.235	,	0.228	,	0.282	,	0.282	,
0	,	0.335	,	0.37	,	0.512	,	0.549	,	0.433	,	0.38	,	0.256	,	0.236	,	0.225	,	0.28	,	0.28	,
0	,	0.329	,	0.369	,	0.512	,	0.554	,	0.448	,	0.39	,	0.265	,	0.236	,	0.222	,	0.278	,	0.278	,
0	,	0.222	,	0.277	,	0.44	,	0.52	,	0.467	,	0.416	,	0.296	,	0.238	,	0.211	,	0.289	,	0.289	,
0	,	0.113	,	0.189	,	0.37	,	0.472	,	0.47	,	0.421	,	0.301	,	0.244	,	0.217	,	0.299	,	0.299	,
0	,	-0.237	,	-0.098	,	0.137	,	0.292	,	0.44	,	0.427	,	0.303	,	0.252	,	0.221	,	0.321	,	0.321	,
0	,	-1.408	,	-1.094	,	-0.72	,	-0.475	,	-0.197	,	-0.071	,	-0.103	,	-0.009	,	0.018	,	0.113	,	0.113	,
0	,	-1.126	,	-0.969	,	-0.627	,	-0.409	,	-0.194	,	-0.096	,	-0.109	,	-0.028	,	0.002	,	0.038	,	0.038	,
0	,	-0.368	,	-0.92	,	-0.59	,	-0.381	,	-0.185	,	-0.093	,	-0.107	,	-0.029	,	0.002	,	0.035	,	0.035	,
0	,	-0.12	,	-0.791	,	-0.495	,	-0.316	,	-0.158	,	-0.082	,	-0.101	,	-0.031	,	0	,	0.028	,	0.028	,
0	,	-0.111	,	-0.601	,	-0.368	,	-0.232	,	-0.117	,	-0.063	,	-0.089	,	-0.029	,	-0.004	,	0.02	,	0.02	,
0	,	-0.108	,	-0.571	,	-0.352	,	-0.222	,	-0.112	,	-0.061	,	-0.087	,	-0.029	,	-0.005	,	0.019	,	0.019	,
0	,	-0.087	,	-0.054	,	-0.246	,	-0.154	,	-0.082	,	-0.046	,	-0.072	,	-0.031	,	-0.01	,	0.015	,	0.015	,
0	,	-0.086	,	-0.03	,	-0.238	,	-0.148	,	-0.08	,	-0.045	,	-0.07	,	-0.031	,	-0.01	,	0.014	,	0.014	,
0	,	-0.099	,	-0.014	,	-0.18	,	-0.111	,	-0.062	,	-0.037	,	-0.059	,	-0.029	,	-0.013	,	0.011	,	0.011	,
0	,	-0.104	,	-0.021	,	-0.176	,	-0.108	,	-0.06	,	-0.036	,	-0.058	,	-0.029	,	-0.013	,	0.01	,	0.01	,
0	,	-0.162	,	-0.079	,	-0.157	,	-0.096	,	-0.053	,	-0.032	,	-0.053	,	-0.028	,	-0.014	,	0.008	,	0.008	,
0	,	-0.431	,	-0.296	,	-0.226	,	-0.134	,	-0.065	,	-0.033	,	-0.049	,	-0.027	,	-0.014	,	0.007	,	0.007	,
0	,	0.04	,	0.038	,	-0.262	,	-0.219	,	-0.142	,	-0.11	,	-0.206	,	-0.105	,	-0.061	,	-0.022	,	-0.022	,
0	,	0.055	,	0.074	,	-0.268	,	-0.224	,	-0.142	,	-0.113	,	-0.194	,	-0.103	,	-0.061	,	-0.018	,	-0.018	;


//

    double Optmization_Thickness=0;
//
    double COMPONENT_RADIUS[Input_Flag_input.No_of_components],COMPONENT_THETA[Input_Flag_input.No_of_components],COMPONENT_LENGTH[Input_Flag_input.No_of_components];
//
    typedef map<string, Geometry>Geometry_Component;
	Geometry_Component COMPONENT;

 double Mass_rate_Char, Mass_rate_Pyrolysis;

    string COMP_NO,NUMBER;






    COMPONENT["Component_1"].Radius=0.7;
    COMPONENT["Component_1"].Theta=20*(M_PI/180);
    COMPONENT["Component_1"].Length=2.589;

    COMPONENT["Component_2"].Radius=0;
    COMPONENT["Component_2"].Theta= 0*(M_PI/180);
    COMPONENT["Component_2"].Length=4.5;

    COMPONENT["Component_3"].Radius=0;
    COMPONENT["Component_3"].Theta= -15*(M_PI/180);
    COMPONENT["Component_3"].Length=0.75;

	for(int ii=1;ii<=Input_Flag_input.No_of_components;ii++)
    {
        NUMBER=to_string(ii);
       COMP_NO="Component_" + NUMBER;
       COMPONENT_RADIUS[ii-1]= COMPONENT[COMP_NO].Radius;
       COMPONENT_THETA[ii-1]= COMPONENT[COMP_NO].Theta;
       COMPONENT_LENGTH[ii-1]= COMPONENT[COMP_NO].Length;

    }


Geometry Component_1;
Component_1 =  COMPONENT["Component_1"];





    int OPTIMIZATION_LOOP_STOP=0;
    int OPTIMIZATION_ITERATION=0;
	for (int jim = 1; jim <= No_of_Layers; jim++)
	{
		//Inverse_nodes(jim-1) = 1/No_of_nodes(jim-1);
		Inverse_nodes(jim - 1) = pow(No_of_nodes(jim - 1), -1);
	}

    int No_of_delt_steps;
    No_of_delt_steps=4;

	MatrixXd Time_variation_for_delt(No_of_delt_steps,1);
    MatrixXd delt_for_various_time(No_of_delt_steps,1);

Time_variation_for_delt << 0,20,50,250;
delt_for_various_time << 0.1,0.1,0.5,1;


double Layer_thickness_old_char, Layer_thickness_old_virgin;



    typedef map<string, Material_Property>Material_PropertyMap;
	Material_PropertyMap MP;

	double Temp_Ablation, Temp_Pyrolysis, Heat_of_Pyrolysis, Heat_of_Ablation, Density_of_Virgin, Density_of_Char, Density_of_Pyrolysis_gas;


//
//
//////////////////////////////////////////////////////////////////// MATERIAL LIBRARY START ///////////////////////////////////////////////
//
//// ALUMINIUM
	MP["Material_Data_Index_1"].k = VectorXd::Zero(2);
    MP["Material_Data_Index_1"].rho = VectorXd::Zero(2);
	MP["Material_Data_Index_1"].Cp = VectorXd::Zero(2);
	MP["Material_Data_Index_1"].epsilon = VectorXd::Zero(2);
	MP["Material_Data_Index_1"].Temp_k = VectorXd::Zero(2);
	MP["Material_Data_Index_1"].Temp_Cp = VectorXd::Zero(2);
	MP["Material_Data_Index_1"].Temp_rho = VectorXd::Zero(2);
	MP["Material_Data_Index_1"].Temp_epsilon = VectorXd::Zero(2);


	MP["Material_Data_Index_1"].k << 121, 121;
	MP["Material_Data_Index_1"].rho << 2800, 2800;
	MP["Material_Data_Index_1"].Cp << 963, 963;
	MP["Material_Data_Index_1"].epsilon << 0.7, 0.7;

	MP["Material_Data_Index_1"].Temp_k << 300, 3000;
	MP["Material_Data_Index_1"].Temp_rho << 300, 3000;
	MP["Material_Data_Index_1"].Temp_Cp << 300, 3000;
	MP["Material_Data_Index_1"].Temp_epsilon << 300, 3000;

	MP["Material_Data_Index_1"].T_Ablation = 5000;
	MP["Material_Data_Index_1"].T_Pyrolysis = 5000;
	MP["Material_Data_Index_1"].Heat_Ablation = 1;
	MP["Material_Data_Index_1"].Heat_Pyrolysis = 2;
	MP["Material_Data_Index_1"].Density_Char = 3;
	MP["Material_Data_Index_1"].Density_Virgin = 4;
	MP["Material_Data_Index_1"].Density_Pyrolysis_gas = 5;


// CFRP
	MP["Material_Data_Index_2"].k = VectorXd::Zero(4);
    MP["Material_Data_Index_2"].rho = VectorXd::Zero(2);
	MP["Material_Data_Index_2"].Cp = VectorXd::Zero(6);
	MP["Material_Data_Index_2"].epsilon = VectorXd::Zero(2);
	MP["Material_Data_Index_2"].Temp_k = VectorXd::Zero(4);
	MP["Material_Data_Index_2"].Temp_Cp = VectorXd::Zero(6);
	MP["Material_Data_Index_2"].Temp_rho = VectorXd::Zero(2);
	MP["Material_Data_Index_2"].Temp_epsilon = VectorXd::Zero(2);


	MP["Material_Data_Index_2"].k << 0.2930760,	0.2930760,	0.33913080,	0.40611960;
	MP["Material_Data_Index_2"].rho << 1120, 1120;
	MP["Material_Data_Index_2"].Cp << 921.0960,	921.0960,	1088.5680,	1214.1720,	1381.6440,	1465.380;
	MP["Material_Data_Index_2"].epsilon << 0.8, 0.8;

	MP["Material_Data_Index_2"].Temp_k << 100, 333, 373, 423;
	MP["Material_Data_Index_2"].Temp_rho << 100, 3000;
	MP["Material_Data_Index_2"].Temp_Cp << 100, 323, 373, 423, 473, 523;
	MP["Material_Data_Index_2"].Temp_epsilon << 100, 3000;

	MP["Material_Data_Index_2"].T_Ablation = 8000;
	MP["Material_Data_Index_2"].T_Pyrolysis = 8000;
	MP["Material_Data_Index_2"].Heat_Ablation = 1;
	MP["Material_Data_Index_2"].Heat_Pyrolysis = 2;
	MP["Material_Data_Index_2"].Density_Char = 3;
	MP["Material_Data_Index_2"].Density_Virgin = 4;
	MP["Material_Data_Index_2"].Density_Pyrolysis_gas = 5;

// STEEL SS304
    MP["Material_Data_Index_3"].k = VectorXd::Zero(2);
    MP["Material_Data_Index_3"].rho = VectorXd::Zero(2);
	MP["Material_Data_Index_3"].Cp = VectorXd::Zero(2);
	MP["Material_Data_Index_3"].epsilon = VectorXd::Zero(2);
	MP["Material_Data_Index_3"].Temp_k = VectorXd::Zero(2);
	MP["Material_Data_Index_3"].Temp_Cp = VectorXd::Zero(2);
	MP["Material_Data_Index_3"].Temp_rho = VectorXd::Zero(2);
	MP["Material_Data_Index_3"].Temp_epsilon = VectorXd::Zero(2);


	MP["Material_Data_Index_3"].k << 53.62, 53.62;
	MP["Material_Data_Index_3"].rho << 7817,7817;
	MP["Material_Data_Index_3"].Cp << 460.46,460.46;
	MP["Material_Data_Index_3"].epsilon << 0.16, 0.16;

	MP["Material_Data_Index_3"].Temp_k << 100, 3000;
	MP["Material_Data_Index_3"].Temp_rho << 100, 3000;
	MP["Material_Data_Index_3"].Temp_Cp << 100, 3000;
	MP["Material_Data_Index_3"].Temp_epsilon << 100, 3000;

	MP["Material_Data_Index_3"].T_Ablation = 8000;
	MP["Material_Data_Index_3"].T_Pyrolysis = 8000;
	MP["Material_Data_Index_3"].Heat_Ablation = 1;
	MP["Material_Data_Index_3"].Heat_Pyrolysis = 2;
	MP["Material_Data_Index_3"].Density_Char = 3;
	MP["Material_Data_Index_3"].Density_Virgin = 4;
	MP["Material_Data_Index_3"].Density_Pyrolysis_gas = 5;

// COLUMBIUM

    MP["Material_Data_Index_4"].k = VectorXd::Zero(4);
    MP["Material_Data_Index_4"].rho = VectorXd::Zero(2);
	MP["Material_Data_Index_4"].Cp = VectorXd::Zero(2);
	MP["Material_Data_Index_4"].epsilon = VectorXd::Zero(2);
	MP["Material_Data_Index_4"].Temp_k = VectorXd::Zero(4);
	MP["Material_Data_Index_4"].Temp_Cp = VectorXd::Zero(2);
	MP["Material_Data_Index_4"].Temp_rho = VectorXd::Zero(2);
	MP["Material_Data_Index_4"].Temp_epsilon = VectorXd::Zero(2);


	MP["Material_Data_Index_4"].k << 14.65380,18.421920,22.399380,24.4090440;
	MP["Material_Data_Index_4"].rho << 913,913;
	MP["Material_Data_Index_4"].Cp << 385.18560,385.18560;
	MP["Material_Data_Index_4"].epsilon << 0.4, 0.4;

	MP["Material_Data_Index_4"].Temp_k << 300.0,500.0,700.0,800.00;
	MP["Material_Data_Index_4"].Temp_rho << 100, 3000;
	MP["Material_Data_Index_4"].Temp_Cp << 100, 3000;
	MP["Material_Data_Index_4"].Temp_epsilon << 100, 3000;

	MP["Material_Data_Index_4"].T_Ablation = 5000;
	MP["Material_Data_Index_4"].T_Pyrolysis = 3300;
	MP["Material_Data_Index_4"].Heat_Ablation = 1;
	MP["Material_Data_Index_4"].Heat_Pyrolysis = 2;
	MP["Material_Data_Index_4"].Density_Char = 3;
	MP["Material_Data_Index_4"].Density_Virgin = 4;
	MP["Material_Data_Index_4"].Density_Pyrolysis_gas = 5;
//PC-10

    MP["Material_Data_Index_5"].k = VectorXd::Zero(4);
    MP["Material_Data_Index_5"].rho = VectorXd::Zero(2);
	MP["Material_Data_Index_5"].Cp = VectorXd::Zero(7);
	MP["Material_Data_Index_5"].epsilon = VectorXd::Zero(2);
	MP["Material_Data_Index_5"].Temp_k = VectorXd::Zero(4);
	MP["Material_Data_Index_5"].Temp_Cp = VectorXd::Zero(7);
	MP["Material_Data_Index_5"].Temp_rho = VectorXd::Zero(2);
	MP["Material_Data_Index_5"].Temp_epsilon = VectorXd::Zero(2);


	MP["Material_Data_Index_5"].k << 0.1632852000,0.163285200,0.163285200,0.163285200;
	MP["Material_Data_Index_5"].rho << 1000,1000;
	MP["Material_Data_Index_5"].Cp << 1590.9840,	1590.9840,	1632.8520,	1716.5880,	1758.4560,	1800.32400,	1800.3240;
	MP["Material_Data_Index_5"].epsilon << 0.89, 0.89;

	MP["Material_Data_Index_5"].Temp_k << 300.0,500.0,700.0,800.00;
	MP["Material_Data_Index_5"].Temp_rho << 100, 3000;
	MP["Material_Data_Index_5"].Temp_Cp << 300.0, 373.0, 398.0 ,423.0 ,448.0 ,473.0 ,600.0;
	MP["Material_Data_Index_5"].Temp_epsilon << 100, 3000;

	MP["Material_Data_Index_5"].T_Ablation = 5000;
	MP["Material_Data_Index_5"].T_Pyrolysis = 773;
	MP["Material_Data_Index_5"].Heat_Ablation = 1;
	MP["Material_Data_Index_5"].Heat_Pyrolysis = 10467000;
	MP["Material_Data_Index_5"].Density_Char = 0;
	MP["Material_Data_Index_5"].Density_Virgin = 1000;
	MP["Material_Data_Index_5"].Density_Pyrolysis_gas = 0;



//PMC-30







///////////////////////////////////////////////////////// ///////MATERIAL LIBRARY END//////////////////////////////////////////////////////////////////
//
//
//
//
//
//

//
//
//
//
//
//	// Thickness Optimization Loop starts
	while (OPTIMIZATION_LOOP_STOP==0)
	{

    if(Initial_Layer_thickness(Input_Flag_input.Index_of_Layer_where_thickness_to_be_optimized-1)<0)
    {
        Initial_Layer_thickness(Input_Flag_input.Index_of_Layer_where_thickness_to_be_optimized-1)=0;
    }

    Layer_thickness_OPTIMIZED_PREVIOUS_ITERATION=Initial_Layer_thickness(Input_Flag_input.Index_of_Layer_where_thickness_to_be_optimized-1);
	Layer_thickness = Initial_Layer_thickness;

	Mass_rate_Char = 0;
	Mass_rate_Pyrolysis = 0;



	Tinitial = VectorXd::Constant(No_of_nodes.sum() + 1, 300);

if(Input_Flag_input.Uniform_Initial_Temperature==0)
{
double Temperature_1=300;
double Temperature_2=20;
int Node_upto_Temp1=50;
int Node_after_Temp2=120;

for(int i_before=1;i_before<=Node_upto_Temp1+1;i_before++)
{
    Tinitial(i_before-1) = Temperature_1;
}

for(int i_before=Node_upto_Temp1+1;i_before<=Node_after_Temp2+1;i_before++)
{
    Tinitial(i_before-1) = Temperature_1 + ((Temperature_2-Temperature_1)/(Node_after_Temp2-Node_upto_Temp1))*(i_before-Node_upto_Temp1);
}

for(int i_before=Node_after_Temp2+1;i_before<=No_of_nodes.sum()+1;i_before++)
{
    Tinitial(i_before-1) = Temperature_2;
}

}

//
//
//
//
  Body(COMPONENT_RADIUS, COMPONENT_THETA, COMPONENT_LENGTH, Analysis_Location, Running_length, Input_Flag_input, IC);
//
//
//
//
//
//
//

	VectorXd T, SS;
	// T = MatrixXd::Zero(No_of_nodes.sum()+1, 1);
	T = Tinitial;

	SS = VectorXd::Zero(No_of_nodes.sum() + 1, 1);





	VectorXd k,rho,Cp,epsilon;
	k = VectorXd::Constant(No_of_nodes.sum()+No_of_Layers,0);
    rho= VectorXd::Constant(No_of_nodes.sum()+No_of_Layers,0);

    Cp= VectorXd::Constant(No_of_nodes.sum()+No_of_Layers,0);

    epsilon= VectorXd::Constant(No_of_nodes.sum()+No_of_Layers,0);


    string str1 = to_string(Material_Index(0));

    string MATERIAL_LIBRARY;
    string MAT_LAYER;

	MATERIAL_LIBRARY = "Material_Data_Index_" + str1;

    MAT_LAYER="Material_Layer_"+to_string(1);

	MP[MAT_LAYER] = MP[MATERIAL_LIBRARY];

	//cout << MP[MAT_LAYER].k << endl;


      for(int nodes0_j=0; nodes0_j <= No_of_nodes(0);nodes0_j++)
       {

         Linear_Interpolation(T(nodes0_j),k(nodes0_j), MP[MAT_LAYER].k.size(), MP[MAT_LAYER].Temp_k , MP[MAT_LAYER].k);
         Linear_Interpolation( T(nodes0_j),rho(nodes0_j), MP[MAT_LAYER].rho.size(), MP[MAT_LAYER].Temp_rho , MP[MAT_LAYER].rho);
         Linear_Interpolation( T(nodes0_j),Cp(nodes0_j),MP[MAT_LAYER].Cp.size(), MP[MAT_LAYER].Temp_Cp , MP[MAT_LAYER].Cp);
         Linear_Interpolation( T(nodes0_j),epsilon(nodes0_j), MP[MAT_LAYER].epsilon.size(), MP[MAT_LAYER].Temp_epsilon , MP[MAT_LAYER].epsilon);
        }

//
   if(No_of_Layers>1)
   {


   for(int mat_j = 1; mat_j < No_of_Layers; mat_j++)
   {


    MAT_LAYER="Material_Layer_"+to_string(mat_j+1);

   MATERIAL_LIBRARY = "Material_Data_Index_" + to_string(Material_Index(mat_j));


    MP[MAT_LAYER] = MP[MATERIAL_LIBRARY];


   VectorXi Nodes_till_jm1;
   Nodes_till_jm1=No_of_nodes.segment(0,mat_j);
   int Sum_till_j=Nodes_till_jm1.sum();

       for(int nodes_j=Sum_till_j+mat_j; nodes_j <= Sum_till_j+No_of_nodes(mat_j)+mat_j; nodes_j++)
       {

         Linear_Interpolation(T(nodes_j-mat_j),k(nodes_j), MP[MAT_LAYER].k.size(),  MP[MAT_LAYER].Temp_k , MP[MAT_LAYER].k );
         Linear_Interpolation(T(nodes_j-mat_j),rho(nodes_j),  MP[MAT_LAYER].rho.size(),  MP[MAT_LAYER].Temp_rho , MP[MAT_LAYER].rho );
         Linear_Interpolation(T(nodes_j-mat_j),Cp(nodes_j), MP[MAT_LAYER].Cp.size(),  MP[MAT_LAYER].Temp_Cp , MP[MAT_LAYER].Cp );
         Linear_Interpolation(T(nodes_j-mat_j),epsilon(nodes_j),  MP[MAT_LAYER].epsilon.size(),  MP[MAT_LAYER].Temp_epsilon , MP[MAT_LAYER].epsilon );
       }

   }

   }




Temp_Ablation=MP["Material_Layer_1"].T_Ablation;
Temp_Pyrolysis=MP["Material_Layer_1"].T_Pyrolysis;
Heat_of_Pyrolysis=MP["Material_Layer_1"].Heat_Pyrolysis;
Heat_of_Ablation=MP["Material_Layer_1"].Heat_Ablation;
Density_of_Virgin=MP["Material_Layer_1"].Density_Virgin;
Density_of_Char=MP["Material_Layer_1"].Density_Char;
Density_of_Pyrolysis_gas=MP["Material_Layer_1"].Density_Pyrolysis_gas;

//
////Perturbation in Ablative_Properties
//
//// Time loop start here


	TIME_STORED(0)= Time_start;
    TEMP_STORED.row(0)=T;


	time = Time_start;
//

	while (time < Time_end)
		{

        for (int To_get_delt = 0; To_get_delt <= No_of_delt_steps ; To_get_delt++)
		{
			if (time <= Time_variation_for_delt(To_get_delt))
			{

				delt = delt_for_various_time(To_get_delt);
				break;
			}
		}

time = time + delt;
delt_store=delt;


TIME_STEP_REDUCED_ITERATION=0;


          if(Input_Flag_input.Convective_data==0)
          {
            Traj.Time = time;

            Linear_Interpolation(Traj.Time, Traj.Altitude, 251, Time_input, Altitude_input);
            Linear_Interpolation(Traj.Time, Traj.Velocity, 251, Time_input, Velocity_input);

            ISA_Nominal(Traj, Freestream);
            Compute_Freestream_Properties(Traj, Freestream, Reference_length,Input_Flag_input);
          }

          if(Input_Flag_input.Convective_data==1)
          {
            User_Input_h_Tg.Time = time;
           // cout <<   Time_input << endl;
            Linear_Interpolation(User_Input_h_Tg.Time, User_Input_h_Tg.h, No_of_lines, Time_input, h_input);
            Linear_Interpolation(User_Input_h_Tg.Time, User_Input_h_Tg.Tg, No_of_lines, Time_input, Tg_input);

          }




           // 0: Ideal Shock, 1: Ideal Shock, 2: Real Shock
          if(Input_Flag_input.Shock_characteristics==1)
          {
              Compute_Downstream_Properties_Ideal(Freestream, Downstream_Ideal, Theta, Downstream_Total, Reference_length);

          }
			else if(Input_Flag_input.Shock_characteristics==2)
           {
                Compute_Downstream_Properties_Real(Freestream, Downstream_Ideal, Downstream_Real, Downstream_Total, Theta, Reference_length);
           }
			else if(Input_Flag_input.Shock_characteristics==0)
           {
               Downstream_Ideal=Freestream;
               Downstream_Total.Temperature = Freestream.Temperature * (1 + 0.5 * (Freestream.Gamma - 1) * pow(Freestream.Mach, 2));
               Downstream_Total.Pressure = Freestream.Pressure * (pow((1 + 0.5 * (Freestream.Gamma - 1) * pow(Freestream.Mach, 2)), (Freestream.Gamma / (Freestream.Gamma - 1))));
           }
//
			Compute_Cp(Coefficient_of_Pressure,Input_Flag_input, Freestream, Analysis_Location,No_of_lines_Location,No_of_lines_Mach, Mach_Table, Location_Table, COP_Table);

			Compute_Properties_Edge(Freestream, Downstream_Ideal, Downstream_Real, Downstream_Total, Edge, Input_Flag_input, Coefficient_of_Pressure,Theta, Reference_length);

//
////determine whether flow is freemolecular or continumm
if(Running_length==0)
{
      Knudsen_number = (Freestream.Viscosity * sqrt((0.5 * M_PI) / (287 * Freestream.Temperature))) / (Reference_length * Freestream.Density);
}
 else
 {

     Knudsen_number = sqrt(0.5*M_PI*Freestream.Gamma)*pow(((Edge.Mach*Edge.Viscosity)/(Running_length*Edge.Velocity*Edge.Density)),1);

 }


 if(Knudsen_number>=0.001)
 {
     Flow_Regime = 1;
 }
 else if(Knudsen_number>=10)
 {
     Flow_Regime = 2;
 }
 else
 {
     Flow_Regime=0;
 }

CONVERGENCE_CONDITIONS_MET=0;
TIME_STEP_REDUCED_ITERATION=0;
INNER_ITER=0;

   while (TIME_STEP_REDUCED_ITERATION<=10 && (INNER_ITER>10 || CONVERGENCE_CONDITIONS_MET == 0))
			{
//				//INNER_ITER = 0;
//
				while (INNER_ITER <= 10 && CONVERGENCE_CONDITIONS_MET==0)
//
				{
					INNER_ITER = INNER_ITER + 1;
//
					if ((T(No_of_nodes(0) > Temp_Pyrolysis - TOLERANCE_1)) && IXFIST == 0)
					{
						if (Input_Flag_input.Sublime == 0)
						{
							for (int ijk=0;ijk<No_of_nodes(0);ijk++)
							{
								NODES_1 = No_of_nodes(0) -1 - ijk;
								T(NODES_1) = T(NODES_1 + 1);
							}
							IXFIST = 1;
						}

					else
					{
						     IXFIST = 1;
					}
					}

if(Input_Flag_input.Air_Gap_Layer != 0)
{

   VectorXi Nodes_till_air_layer;
   Nodes_till_air_layer=No_of_nodes.segment(0,Input_Flag_input.Air_Gap_Layer-1);
   int Sum_till_air_layer=Nodes_till_air_layer.sum();
//
 Air_Gap(h_convection_air_gap, h_radiation_air_gap, AIR_GAP_THICKNESS, LENGTH_OVER_WHICH_AIR_GAP, T(Sum_till_air_layer),T(Sum_till_air_layer+No_of_nodes(Input_Flag_input.Air_Gap_Layer)),Sea_Level_Pressure,Emmisivity_1,Emmisivity_2,Input_Flag_input);

}

	  MAT_LAYER="Material_Layer_"+to_string(1);
	  for(int nodes0_j=0; nodes0_j <= No_of_nodes(0);nodes0_j++)
       {

         Linear_Interpolation(T(nodes0_j),k(nodes0_j), MP[MAT_LAYER].k.size(), MP[MAT_LAYER].Temp_k , MP[MAT_LAYER].k);
         Linear_Interpolation( T(nodes0_j),rho(nodes0_j), MP[MAT_LAYER].rho.size(), MP[MAT_LAYER].Temp_rho , MP[MAT_LAYER].rho);
         Linear_Interpolation( T(nodes0_j),Cp(nodes0_j),MP[MAT_LAYER].Cp.size(), MP[MAT_LAYER].Temp_Cp , MP[MAT_LAYER].Cp);
         Linear_Interpolation( T(nodes0_j),epsilon(nodes0_j), MP[MAT_LAYER].epsilon.size(), MP[MAT_LAYER].Temp_epsilon , MP[MAT_LAYER].epsilon);
        }



//
   if(No_of_Layers>1)
   {


   for(int mat_j = 1; mat_j < No_of_Layers; mat_j++)
   {


    MAT_LAYER="Material_Layer_"+to_string(mat_j+1);

   VectorXi Nodes_till_jm1;
   Nodes_till_jm1=No_of_nodes.segment(0,mat_j);
   int Sum_till_j=Nodes_till_jm1.sum();

       for(int nodes_j=Sum_till_j+mat_j; nodes_j <= Sum_till_j+No_of_nodes(mat_j)+mat_j; nodes_j++)
       {

         Linear_Interpolation(T(nodes_j-mat_j),k(nodes_j), MP[MAT_LAYER].k.size(),  MP[MAT_LAYER].Temp_k , MP[MAT_LAYER].k );
         Linear_Interpolation(T(nodes_j-mat_j),rho(nodes_j),  MP[MAT_LAYER].rho.size(),  MP[MAT_LAYER].Temp_rho , MP[MAT_LAYER].rho );
         Linear_Interpolation(T(nodes_j-mat_j),Cp(nodes_j), MP[MAT_LAYER].Cp.size(),  MP[MAT_LAYER].Temp_Cp , MP[MAT_LAYER].Cp );
         Linear_Interpolation(T(nodes_j-mat_j),epsilon(nodes_j),  MP[MAT_LAYER].epsilon.size(),  MP[MAT_LAYER].Temp_epsilon , MP[MAT_LAYER].epsilon );


         if(mat_j==Input_Flag_input.Air_Gap_Layer-1)
         {
             Cp(nodes_j) =0;
             k(nodes_j) = k(nodes_j) + Layer_thickness(mat_j-1)*(abs(h_convection_air_gap+h_radiation_air_gap));
         }
       }
// add perturbation terms also here
   }
   }
//

					T_wall = T(0);
					Boundary_Node = 0;
					if (Layer_thickness(0) == 0)
					{
						T_wall = T(No_of_nodes(0));
						Boundary_Node = No_of_nodes(0);
					}
					else if (Layer_thickness(0) == 0 && Layer_thickness(1) == 0)
					{
						T_wall = T(No_of_nodes(0)+No_of_nodes(1));
						Boundary_Node = No_of_nodes(0) + No_of_nodes(1);
					}

			wall.Temperature= T_wall;
            Compute_Properties_wall(Freestream, Downstream_Ideal, Downstream_Real, Edge, Downstream_Total, wall,Running_length);




            if((Flow_Regime==0 || Flow_Regime==1) && Input_Flag_input.Convective_data != 1)
            {
                if(Running_length==0)
                {
                    //Fay Ridell, // Beckwith Gallaghar
                    Stagnation_Heating(HF_Convective, Downstream_Total, wall, Freestream, Downstream_Ideal, Input_Flag_input, Component_1, Temperature_recovery);
                    HF_Convective.q_continum=HF_Convective.q_Stagnation;
                }
                else if(Running_length <= COMPONENT["Component_1"].Radius*(M_PI/2-COMPONENT["Component_1"].Theta))
                {
                    // Lees
                    Stagnation_Heating(HF_Convective, Downstream_Total, wall, Freestream, Downstream_Ideal, Input_Flag_input, Component_1, Temperature_recovery);
                    Lees_Heating(Freestream, HF_Convective, Component_1, Analysis_Location,Running_length);
                     HF_Convective.q_continum=HF_Convective.q_Lees_spherical;

                }
                else
                {
                    //Eckert Van driest
                    Flat_Plate_Heating(HF_Convective, Downstream_Total, wall, Freestream, Downstream_Ideal,Downstream_Real, Edge, Input_Flag_input, Analysis_Location, Running_length, Re_transition, RETS,Re_transition_criteria,Rey_No_Edge1, Transition_based_on_Retheta,Temperature_recovery);
                     HF_Convective.q_continum=HF_Convective.q_Flat_Plate;

                }
            }

            if(Input_Flag_input.Convective_data==1)
            {
                heat_transfer_coefficient_outer=User_Input_h_Tg.h;
                Temperature_recovery = User_Input_h_Tg.Tg;
                HF_Convective.q_aero_net = heat_transfer_coefficient_outer*(Temperature_recovery-wall.Temperature);
            }



//// Compute Free Molecular
Free_Molecular_Heating(Freestream, HF_Convective, wall,Kn_Bridging_Factor);

Kn_Bridging_Factor=Knudsen_number;
HF_Convective.q_aero_net = Kn_Bridging_Factor * HF_Convective.q_FreeMolecular + (1 - Kn_Bridging_Factor) * HF_Convective.q_continum;

cout << time << " " <<  HF_Convective.q_aero_net/10000   << endl;
//// get perturbation due to protrusion
//

double Qradiation,Tspace,Propellant_Mass;

double X1_Thin, X2_Thin,Outer_Radius;
X1_Thin=0;
X2_Thin=0;
Outer_Radius=0;

Qradiation=1000;
Tspace=00;
Propellant_Mass=0;

heat_transfer_coefficient_outer = HF_Convective.q_aero_net/(Temperature_recovery-wall.Temperature);
//cout << time << " " << heat_transfer_coefficient_outer << endl;

//cout << heat_transfer_coefficient_outer << endl;

Tg=Temperature_recovery;
//
if(Input_Flag_input.No_Thermal_response !=1)
{
//

//
Layer_thickness_old_char=Layer_thickness(0);
Layer_thickness_old_virgin=Layer_thickness(1);

if((No_of_Layers>=2 && Layer_thickness(0)!=0 && Layer_thickness(1)!=0) || (Mass_rate_Pyrolysis !=0 || T(No_of_nodes(0))>Temp_Pyrolysis-1))
{

Instantaneous_MassRate_Thickness(HF_Convective, Qradiation, No_of_nodes, Inverse_nodes, Layer_thickness, epsilon, Temp_Ablation, Temp_Pyrolysis, Heat_of_Pyrolysis, Heat_of_Ablation, Density_of_Virgin,  Density_of_Char, Density_of_Pyrolysis_gas,  T,  Tinitial, delt, Mass_rate_Char, Mass_rate_Pyrolysis, Input_Flag_input,  X1_Thin,  X2_Thin, TOLERANCE_1, k);

}

if(Layer_thickness(1)<0.000001)
{
    Layer_thickness(1)=0;
}

//
//


Back_wall_Convection_ON=0;
Backwall_wall_Radiation_loss_ON=0;
T_Ambient_Convection=0;
h_convection_backwall=0;
Characteristic_Length_backwall_convection=0;
Sea_Level_Pressure=101325;
Use_Correlation_or_value_backwall_convection=0;  // 0 for correlation, 1 for h value
Q_RADIATION_BACKWALL=0;
T_Ambient_Radiation=0;

//
//
//Thermal_Response(No_of_Layers, No_of_nodes, Inverse_nodes, Material_Index, Initial_Layer_thickness, Layer_thickness, Qradiation, heat_transfer_coefficient_outer, Tg, Tspace, k, Cp, rho, epsilon, Temp_Ablation, Temp_Pyrolysis, Heat_of_Pyrolysis, Heat_of_Ablation, Density_of_Virgin, Density_of_Char, Density_of_Pyrolysis_gas, T, Tinitial, delt, Mass_rate_Char, Mass_rate_Pyrolysis, Input_Flag_input, Propellant_Mass, X1_Thin, X2_Thin,Outer_Radius, Cp_Pyrolysis_gas,SS,T_Ambient_Convection,h_convection_backwall, Characteristic_Length_backwall_convection, Sea_Level_Pressure,Use_Correlation_or_value_backwall_convection, Q_RADIATION_BACKWALL, T_Ambient_Radiation, Back_wall_Convection_ON,Backwall_wall_Radiation_loss_ON );
//
//
//cout << time << " " << T(30) << endl ;
			if(abs(T(Boundary_Node) - T_wall)<TOLERANCE_1)
            {
                CONVERGENCE_CONDITIONS_MET=1;
            }
					double DX1, DX2, PDX1, PDX2;
					DX1 = abs(Layer_thickness(0) - Layer_thickness_old_char);
					DX2 = abs(Layer_thickness(1) - Layer_thickness_old_virgin);
					PDX1 = 0;
					PDX2 = 0;
					if (Layer_thickness(0) != 0)
					{
						PDX1 = DX1 / Layer_thickness(0);
					}
					if (Layer_thickness(1) != 0)
					{
						PDX2 = DX2 / Layer_thickness(1);
					}
                 if((T(0)>Temp_Ablation+1 && Mass_rate_Char>0.00001) || (T(No_of_nodes(0))>Temp_Pyrolysis+1 && Mass_rate_Pyrolysis>0.00001) || (DX1>0.000001 || PDX1>0.001) || (DX2>0.000001 || PDX2>0.001) )
                 {
                     CONVERGENCE_CONDITIONS_MET =0;
                 }
                else
                {
                    CONVERGENCE_CONDITIONS_MET=1;
                }
//
                INNER_ITER = INNER_ITER +1;

}

}

////// time step reduced
////
if(INNER_ITER>10 && CONVERGENCE_CONDITIONS_MET==0)
{
    INNER_ITER=0;
    delt=delt/2;
    TIME_STEP_REDUCED_ITERATION=TIME_STEP_REDUCED_ITERATION+1;
    time=time_store + delt;
    GONE_IN_TIME_STEP_REDUCTION=1;
}
//
//
//
			}
//
if(GONE_IN_TIME_STEP_REDUCTION==1)
{
    GONE_IN_TIME_STEP_REDUCTION=0;
    time_store=time;
    delt=delt_store-delt;
    delt_store=delt;
    time=time_store+delt;

}
//


//
STORED_ARRAY_ID=STORED_ARRAY_ID+1;

TIME_STORED(STORED_ARRAY_ID)= time;
TEMP_STORED.row(STORED_ARRAY_ID)=T;


//
	}

if(Input_Flag_input.Thickness_to_be_optimized ==0)
{
    OPTIMIZATION_LOOP_STOP=1;


}
//
//
else
{
//

 T_MAX=(TEMP_STORED.col(Input_Flag_input.Index_of_Node_where_temperature_constraint_to_be_maintained-1)).maxCoeff();

if(abs(T_MAX-Input_Flag_input.Temp_constarint_to_be_maintained)<=Input_Flag_input.Tolerance_Temperature_constraint || Input_Flag_input.Index_of_Node_where_temperature_constraint_to_be_maintained ==0 || Input_Flag_input.Temp_constarint_to_be_maintained==0)
{
    OPTIMIZATION_LOOP_STOP=1;
}

if(OPTIMIZATION_ITERATION==0 && OPTIMIZATION_LOOP_STOP==0 )
{
 T_MAX1 = T_MAX;

  if(T_MAX1-Input_Flag_input.Temp_constarint_to_be_maintained >=0)
  {
      Initial_Layer_thickness(Input_Flag_input.Index_of_Layer_where_thickness_to_be_optimized-1) = Layer_thickness_OPTIMIZED_PREVIOUS_ITERATION + DX_OPTIMIZED;
  }
   else
   {
       Initial_Layer_thickness(Input_Flag_input.Index_of_Layer_where_thickness_to_be_optimized-1) = Layer_thickness_OPTIMIZED_PREVIOUS_ITERATION - DX_OPTIMIZED;
   }

	OPTIMIZATION_ITERATION=OPTIMIZATION_ITERATION+1;
}

if(IXFIST==1)
{
   Initial_Layer_thickness(0)=0;
}

OPTIMIZATION_ITERATION=OPTIMIZATION_ITERATION+1;

if(OPTIMIZATION_ITERATION>=2&& OPTIMIZATION_LOOP_STOP==0)
{
 if(OPTIMIZATION_ITERATION==2)
  {

       T_MAX2=T_MAX;
  }
  else if(OPTIMIZATION_ITERATION>2)
  {
       T_MAX1=T_MAX2;
  }
//
     T_MAX2=T_MAX;
     DX_OPTIMIZED=abs(DX_OPTIMIZED*((T_MAX2-Input_Flag_input.Temp_constarint_to_be_maintained)/(T_MAX2-T_MAX1)));
    if(T_MAX2-Input_Flag_input.Temp_constarint_to_be_maintained>=0)
    {
        Initial_Layer_thickness(Input_Flag_input.Index_of_Layer_where_thickness_to_be_optimized-1) = Layer_thickness_OPTIMIZED_PREVIOUS_ITERATION + DX_OPTIMIZED;
    }
    else
    {
      Initial_Layer_thickness(Input_Flag_input.Index_of_Layer_where_thickness_to_be_optimized-1) = Layer_thickness_OPTIMIZED_PREVIOUS_ITERATION - DX_OPTIMIZED;
    }
}
//
if(Layer_thickness_OPTIMIZED_PREVIOUS_ITERATION <0.00001 && OPTIMIZATION_ITERATION>2)
{
    OPTIMIZATION_LOOP_STOP=1;
////
}
//
//
	}



}

 //cout << TIME_STORED << " " << TEMP_STORED.col(No_of_nodes.sum()) << endl;

    return 0;



}




